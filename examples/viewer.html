<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Potree Viewer</title>

	<link rel="stylesheet" type="text/css" href="../build/potree/potree.css">
	<link rel="stylesheet" type="text/css" href="../libs/jquery-ui/jquery-ui.min.css">
	<link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css">
	<link rel="stylesheet" type="text/css" href="../libs/spectrum/spectrum.css">
	<link rel="stylesheet" type="text/css" href="../libs/jstree/themes/mixed/style.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
	
	<style>
		/* Base Font Styles */
		body {
			font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif !important;
		}

		/* Navigation Styles */
		.nav-button {
			display: inline-flex !important;
			align-items: center;
			justify-content: center;
			width: 40px;
			height: 40px;
			margin: 4px;
			border: none;
			border-radius: 4px;
			background: rgba(255, 255, 255, 0.1);
			color: #fff;
			
			cursor: pointer;
			transition: background 0.2s;
		}

		.nav-button:hover {
			background: rgba(255, 255, 255, 0.2);
		}

		.nav-button i {
			font-size: 18px;
		}

		/* Hide the potree logo and language selector */
		img[src*="potree-logo"], 
		img[src*="menu_button.svg"],
		#potree_branding,
		#menu_appearance,
		#menu_about,
		#menu_language,
		#potree_languages,
		.divider,
		[data-i18n="appearance.language"],
		[data-i18n="settings.language"] {
			display: none !important;
		}

		/* Remove existing sidebar styles */
		#potree_sidebar_container,
		#potree_menu_toggle {
			display: none !important;
		}

		/* Add new minimal navigation bar */
		.minimal-nav {
			position: fixed;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(50, 50, 50, 0.9);
			backdrop-filter: blur(10px);
			padding: 8px;
			border-radius: 12px;
			display: flex;
			flex-direction: row;
			gap: 0px; /* Remove gap to use consistent button margins instead */
			z-index: 1000;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
		}

		@keyframes slideIn {
			from {
				opacity: 0;
				transform: translate(-50%, -20px);
			}
			to {
				opacity: 1;
				transform: translate(-50%, 0);
			}
		}

		/* Update the nav buttons */
		.nav-button {
			width: 40px;
			height: 40px;
			border-radius: 8px;
			border: none;
			background: rgba(255, 255, 255, 0.1);
			color: white;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: all 0.2s ease;
			margin: 2px; /* Added consistent margin */
		}

		.nav-button:hover {
			background: rgba(255, 255, 255, 0.2);
			transform: translateY(-2px);
		}

		.nav-button.active {
			background: rgba(75, 107, 253, 0.6);
			color: white;
		}

		/* Separator style */
		.nav-separator {
			height: 1px;
			background: rgba(255, 255, 255, 0.2);
			margin: 4px 0;
		}

		/* Style the scrollbar for the navigation panel */
		.minimal-nav::-webkit-scrollbar {
			width: 6px;
		}

		.minimal-nav::-webkit-scrollbar-track {
			background: rgba(255, 255, 255, 0.05);
			border-radius: 3px;
		}

		.minimal-nav::-webkit-scrollbar-thumb {
			background: rgba(75, 107, 253, 0.3);
			border-radius: 3px;
		}

		.minimal-nav::-webkit-scrollbar-thumb:hover {
			background: rgba(75, 107, 253, 0.5);
		}

		/* Make separators more compact */
		.minimal-nav > div[style*="height: 1px"] {
			grid-column: 1 / -1;
			height: 1px;
			background: rgba(255, 255, 255, 0.1);
			margin: 4px 0;
		}

		/* Single-column sections */
		.minimal-nav .view-controls {
			grid-column: 1 / -1;
			display: flex;
			gap: 8px;
		}

		/* Welcome Message Overlay */
		.welcome-overlay {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: rgba(20, 23, 34, 0.95);
			backdrop-filter: blur(12px);
			padding: 2rem;
			border-radius: 15px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
			z-index: 999;
			text-align: center;
			max-width: 400px;
			color: white;
			animation: fadeIn 0.5s ease-out;
		}

		.welcome-overlay h2 {
			margin: 0 0 1rem 0;
			font-size: 1.5rem;
			font-weight: 600;
			color: white;
		}

		.welcome-overlay p {
			margin: 0;
			font-size: 1rem;
			line-height: 1.5;
			color: rgba(255, 255, 255, 0.8);
		}

		.welcome-overlay i {
			font-size: 2.5rem;
			color: #4B6BFD;
			margin-bottom: 1rem;
		}

		@keyframes fadeIn {
			from { opacity: 0; transform: translate(-50%, -60%); }
			to { opacity: 1; transform: translate(-50%, -50%); }
		}

		.welcome-overlay .dismiss {
			position: absolute;
			top: 1rem;
			right: 1rem;
			color: rgba(255, 255, 255, 0.5);
			cursor: pointer;
			font-size: 1.2rem;
			transition: color 0.2s ease;
		}

		.welcome-overlay .dismiss:hover {
			color: rgba(255, 255, 255, 0.9);
		}

		/* Drop Zone Modernization */
		.drop-zone {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(28, 32, 40, 0.9) !important;
			backdrop-filter: blur(12px) !important;
			z-index: 10000;
			display: flex;
			justify-content: center;
			align-items: center;
			pointer-events: none;
			opacity: 0;
			transition: opacity 0.3s ease;
		}

		.drop-zone.active {
			opacity: 1;
			pointer-events: all;
		}

		.drop-zone-text {
			color: rgba(255, 255, 255, 0.95);
			font-size: 28px;
			text-align: center;
			padding: 35px 45px;
			background-color: rgba(40, 44, 52, 0.95) !important;
			backdrop-filter: blur(16px) !important;
			border: 2px solid rgba(255, 255, 255, 0.2) !important;
			box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4) !important;
			border-radius: 20px;
			font-weight: 500;
		}

		/* Loading Message Styles */
		.loading-overlay {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: rgba(40, 44, 52, 0.95);
			backdrop-filter: blur(16px);
			padding: 25px 35px;
			border-radius: 20px;
			border: 2px solid rgba(255, 255, 255, 0.2);
			box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
			color: white;
			font-size: 24px;
			font-weight: 500;
			z-index: 10001;
			text-align: center;
		}

		/* Account Controls */
		#account-controls {
			position: fixed;
			top: 1rem;
			right: 1rem;
			z-index: 10002;
		}

		#user-avatar {
			width: 40px;
			height: 40px;
			border-radius: 50%;
			background: var(--primary-light);
			display: flex;
			align-items: center;
			justify-content: center;
			font-weight: 600;
			font-size: 1.1rem;
			color: white;
			text-transform: uppercase;
			cursor: pointer;
			transition: all 0.3s ease;
			border: 2px solid rgba(255, 255, 255, 0.1);
			position: relative;
			overflow: hidden;
			background: linear-gradient(135deg, #4B6BFD, #2B3ADF);
		}

		#user-avatar i {
			font-size: 1.2rem;
			color: white;
			opacity: 0.95;
		}

		#user-avatar::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: linear-gradient(45deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));
			z-index: 1;
		}

		#user-avatar:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
			border-color: rgba(255, 255, 255, 0.2);
		}

		#user-avatar:hover i {
			transform: scale(1.1);
		}

		#user-avatar i {
			transition: transform 0.3s ease;
			z-index: 2;
		}

		.account-dropdown {
			position: absolute;
			top: calc(100% + 10px);
			right: 0;
			background: rgba(20, 23, 34, 0.95);
			backdrop-filter: blur(12px);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 12px;
			padding: 0.75rem;
			min-width: 200px;
			box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
			opacity: 0;
			visibility: hidden;
			transform: translateY(-10px);
			transition: all 0.3s ease;
		}

		.account-dropdown.active {
			opacity: 1;
			visibility: visible;
			transform: translateY(0);
		}

		.account-dropdown::before {
			content: '';
			position: absolute;
			top: -5px;
			right: 15px;
			width: 10px;
			height: 10px;
			background: rgba(20, 23, 34, 0.95);
			transform: rotate(45deg);
			border-left: 1px solid rgba(255, 255, 255, 0.1);
			border-top: 1px solid rgba(255, 255, 255, 0.1);
		}

		.user-info {
			padding: 0.75rem;
			border-bottom: 1px solid rgba(255, 255, 255, 0.1);
			margin-bottom: 0.75rem;
		}

		.user-name {
			font-weight: 600;
			color: white;
			font-size: 0.95rem;
			margin-bottom: 0.25rem;
		}

		.user-email {
			color: rgba(255, 255, 255, 0.6);
			font-size: 0.85rem;
		}

		.dropdown-item {
			display: flex;
			align-items: center;
			gap: 0.75rem;
			padding: 0.75rem;
			color: white;
			text-decoration: none;
			border-radius: 8px;
			transition: all 0.2s ease;
			cursor: pointer;
		}

		.dropdown-item i {
			font-size: 1rem;
			color: rgba(255, 255, 255, 0.6);
			transition: all 0.2s ease;
		}

		.dropdown-item:hover {
			background: rgba(75, 107, 253, 0.15);
			transform: translateX(-4px);
		}

		.dropdown-item:hover i {
			color: rgba(255, 255, 255, 0.9);
		}

		.dropdown-item.logout {
			color: #ff4d4d;
		}

		.dropdown-item.logout i {
			color: #ff4d4d;
		}

		.dropdown-item.logout:hover {
			background: rgba(255, 77, 77, 0.1);
		}

		/* Add these new styles for sidebar fixes */
		#potree_sidebar_container {
			position: fixed !important;
			right: 0 !important;
			top: 0 !important;
			bottom: 0 !important;
			width: 300px !important;
			background: rgba(20, 23, 34, 0.95) !important;
			backdrop-filter: blur(12px) !important;
			border-left: 1px solid rgba(255, 255, 255, 0.1) !important;
			overflow-y: auto !important;
			overflow-x: hidden !important;
			z-index: 1000 !important;
			transition: transform 0.3s ease !important;
			max-height: 100vh !important;
			padding: 20px !important;
		}

		#potree_sidebar_container.collapsed {
			transform: translateX(300px) !important;
		}

		.potree_sidebar_brand {
			padding: 0 0 20px 0 !important;
			border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
			margin-bottom: 20px !important;
		}

		.pv-menu-list {
			max-height: calc(100vh - 100px) !important;
			overflow-y: auto !important;
			padding-bottom: 40px !important;
		}

		/* Improve scrollbar appearance */
		.pv-menu-list::-webkit-scrollbar {
			width: 8px !important;
		}

		.pv-menu-list::-webkit-scrollbar-track {
			background: rgba(255, 255, 255, 0.05) !important;
			border-radius: 4px !important;
		}

		.pv-menu-list::-webkit-scrollbar-thumb {
			background: rgba(255, 255, 255, 0.2) !important;
			border-radius: 4px !important;
		}

		.pv-menu-list::-webkit-scrollbar-thumb:hover {
			background: rgba(255, 255, 255, 0.3) !important;
		}

		/* Improve form controls layout */
		.pv-menu-list input[type="text"],
		.pv-menu-list input[type="number"],
		.pv-menu-list select {
			max-width: 100% !important;
			width: 100% !important;
			box-sizing: border-box !important;
		}

		/* Fix spacing issues */
		.pv-menu-list > li {
			margin-bottom: 10px !important;
			padding: 10px !important;
			border-radius: 8px !important;
			background: rgba(255, 255, 255, 0.05) !important;
		}

		/* Ensure content doesn't overflow horizontally */
		.pv-menu-list > li > div {
			word-wrap: break-word !important;
			white-space: normal !important;
		}

		/* Logo Styles */
		.desapex-brand {
			position: fixed;
			top: 20px;
			left: 20px;
			display: flex;
			align-items: center;
			gap: 12px;
			z-index: 1000;
			text-decoration: none;
			padding: 8px;
			border-radius: 12px;
			background: rgba(20, 23, 34, 0.85);
			backdrop-filter: blur(12px);
			border: 1px solid rgba(75, 107, 253, 0.2);
			transition: all 0.3s ease;
		}

		.desapex-brand:hover {
			transform: translateY(-2px);
			border-color: rgba(75, 107, 253, 0.4);
			box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
		}

		.desapex-logo {
			width: 32px;
			height: 32px;
			position: relative;
		}

		.logo-shape {
			position: absolute;
			width: 100%;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.logo-shape svg {
			width: 100%;
			height: 100%;
			filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
		}

		.brand-text {
			color: white;
			font-weight: 600;
			font-size: 1.2rem;
			letter-spacing: -0.01em;
			background: linear-gradient(135deg, #fff 0%, rgba(255, 255, 255, 0.8) 100%);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
		}

		/* Add a subtle glow animation */
		@keyframes logoPulse {
			0%, 100% { filter: drop-shadow(0 0 8px rgba(75, 107, 253, 0.3)); }
			50% { filter: drop-shadow(0 0 12px rgba(75, 107, 253, 0.5)); }
		}

		.desapex-logo svg {
			animation: logoPulse 3s ease-in-out infinite;
		}

		/* Add styles for the navigation buttons */
		.nav-button[title*="Navigation"],
		.nav-button[title*="View"] {
			position: relative;
			overflow: hidden;
		}

		.nav-button[title*="Navigation"]::before,
		.nav-button[title*="View"]::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
			opacity: 0;
			transition: opacity 0.2s ease;
		}

		.nav-button[title*="Navigation"]:hover::before,
		.nav-button[title*="View"]:hover::before {
			opacity: 1;
		}

		.nav-button.active {
			background: rgba(0, 153, 255, 0.6) !important;
			box-shadow: 0 0 10px rgba(0, 153, 255, 0.3);
		}

		/* Update the minimal-nav container */
		.minimal-nav {
			position: fixed;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(50, 50, 50, 0.9);
			backdrop-filter: blur(10px);
			padding: 8px;
			border-radius: 12px;
			display: flex;
			flex-direction: row;
			gap: 0px; /* Remove gap to use consistent button margins instead */
			z-index: 1000;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
		}

		/* Add tooltip styles */
		.nav-button:hover::after {
			right: 120%;
			left: auto;
			transform: translateY(-50%);
			background: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 12px;
			white-space: nowrap;
			pointer-events: none;
			z-index: 1001;
		}

		/* Dropdown styles */
		.nav-dropdown {
			position: relative;
			display: inline-block;
		}

		.nav-dropdown-content {
			display: none;
			position: absolute;
			top: 100%;
			left: 0;
			background: rgba(30, 35, 45, 0.95);
			backdrop-filter: blur(12px);
			border-radius: 8px;
			padding: 8px;
			min-width: 180px;
			z-index: 1001;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
			margin-top: 8px;
		}

		.nav-dropdown-content.show {
			display: block;
		}

		.dropdown-item {
			display: flex;
			align-items: center;
			padding: 8px 12px;
			color: white;
			text-decoration: none;
			cursor: pointer;
			border-radius: 4px;
			transition: background-color 0.2s;
		}

		.dropdown-item:hover {
			background: rgba(75, 107, 253, 0.15);
		}

		.dropdown-item.active {
			background: rgba(75, 107, 253, 0.3);
		}

		.nav-button {
			background: rgba(255, 255, 255, 0.1);
			border: none;
			color: white;
			padding: 8px;
			border-radius: 4px;
			cursor: pointer;
			transition: background-color 0.2s;
		}

		.nav-button:hover {
			background: rgba(75, 107, 253, 0.3);
		}

		/* Add dropdown menu styles */
		.nav-dropdown {
			position: relative;
			display: inline-block;
		}

		.nav-dropdown-content {
			display: none;
			position: absolute;
			background: rgba(50, 50, 50, 0.95);
			backdrop-filter: blur(10px);
			min-width: 200px;
			border-radius: 8px;
			padding: 8px;
			z-index: 1001;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
			top: 100%;
			left: 50%;
			transform: translateX(-50%);
			margin-top: 8px;
		}

		.nav-dropdown-content.show {
			display: block;
			animation: fadeIn 0.2s ease;
		}

		.dropdown-item {
			display: flex;
			align-items: center;
			gap: 10px;
			padding: 8px 12px;
			width: 100%;
			border: none;
			background: none;
			color: white;
			cursor: pointer;
			border-radius: 6px;
			transition: all 0.2s ease;
			text-align: left;
		}

		.dropdown-item:hover {
			background: rgba(255, 255, 255, 0.1);
		}

		.dropdown-item i {
			width: 20px;
			text-align: center;
		}

		@keyframes fadeIn {
			from {
				opacity: 0;
				transform: translateY(-10px) translateX(-50%);
			}
			to {
				opacity: 1;
				transform: translateY(0) translateX(-50%);
			}
		}

		/* Add screenshot dialog styles */
		.screenshot-dialog {
			display: none;
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: rgba(30, 35, 45, 0.95);
			backdrop-filter: blur(12px);
			padding: 20px;
			border-radius: 12px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
			z-index: 1002;
			color: white;
			min-width: 300px;
		}

		.screenshot-dialog h3 {
			margin: 0 0 15px 0;
			font-size: 1.2rem;
			font-weight: 600;
		}

		.screenshot-dialog select {
			width: 100%;
			padding: 8px;
			margin-bottom: 15px;
			background: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 6px;
			color: white;
		}

		.screenshot-dialog .buttons {
			display: flex;
			gap: 10px;
			justify-content: flex-end;
		}

		.screenshot-dialog button {
			padding: 8px 16px;
			border: none;
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.screenshot-dialog button.cancel {
			background: rgba(255, 255, 255, 0.1);
			color: white;
		}

		.screenshot-dialog button.take-screenshot {
			background: #4B6BFD;
			color: white;
		}

		.screenshot-dialog button:hover {
			transform: translateY(-2px);
		}

		/* Add styles for saved viewpoints panel */
		.saved-viewpoints-panel {
			display: none;
			position: fixed;
			right: 20px;
			top: 80px;
			background: rgba(30, 35, 45, 0.95);
			backdrop-filter: blur(12px);
			border-radius: 12px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			padding: 16px;
			width: 280px;
			max-height: 400px;
			overflow-y: auto;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
			z-index: 1000;
		}

		.saved-viewpoints-panel h3 {
			margin: 0 0 12px 0;
			color: white;
			font-size: 1.1rem;
			font-weight: 600;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.viewpoint-list {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		.viewpoint-item {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 8px 12px;
			background: rgba(255, 255, 255, 0.1);
			border-radius: 8px;
			color: white;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.viewpoint-item:hover {
			background: rgba(75, 107, 253, 0.2);
			transform: translateX(4px);
		}

		.viewpoint-item .delete-btn {
			background: rgba(255, 77, 77, 0.15);
			border: none;
			border-radius: 4px;
			width: 24px;
			height: 24px;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer !important;
			padding: 0;
			margin-left: 8px;
			color: #ff6b6b;
			transition: all 0.2s ease;
			z-index: 20;
		}

		.viewpoint-item .delete-btn:hover {
			background: rgba(255, 77, 77, 0.8) !important;
			color: white !important;
			transform: scale(1.1);
		}

		.viewpoint-item .delete-btn i {
			font-size: 14px;
		}

		/* Add styles for save viewpoint dialog */
		.save-viewpoint-dialog {
			display: none;
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: rgba(30, 35, 45, 0.95);
			backdrop-filter: blur(12px);
			padding: 20px;
			border-radius: 12px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
			z-index: 1002;
			color: white;
			min-width: 300px;
		}

		.save-viewpoint-dialog input {
			width: 100%;
			padding: 8px;
			margin: 10px 0;
			background: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 6px;
			color: white;
		}

		.save-viewpoint-dialog .buttons {
			display: flex;
			gap: 10px;
			justify-content: flex-end;
			margin-top: 15px;
		}

		.save-viewpoint-dialog button {
			padding: 8px 16px;
			border: none;
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.save-viewpoint-dialog button.cancel {
			background: rgba(255, 255, 255, 0.1);
			color: white;
			font-weight: bold;
			cursor: pointer;
			padding: 10px 16px;
		}

		.save-viewpoint-dialog button.cancel:hover {
			background: rgba(255, 255, 255, 0.2);
		}

		.save-viewpoint-dialog button.save {
			background: #4B6BFD;
			color: white;
		}

		/* Top view map styles */
		.top-view-map {
			position: absolute;
			width: 300px;
			height: 300px;
			right: 20px;
			bottom: 20px;
			border-radius: 8px;
			overflow: hidden;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
			border: 1px solid rgba(75, 107, 253, 0.3);
			z-index: 1000;
			background-color: rgba(30, 35, 45, 0.8);
			backdrop-filter: blur(8px);
			transition: all 0.3s ease;
		}

		.top-view-map:hover {
			border-color: rgba(75, 107, 253, 0.6);
		}

		.map-controls {
			position: absolute;
			top: 8px;
			right: 8px;
			display: flex;
			flex-direction: column;
			gap: 4px;
			z-index: 1001;
		}

		.map-controls button {
			width: 24px;
			height: 24px;
			background: rgba(30, 35, 45, 0.8);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 4px;
			color: white;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			transition: all 0.2s ease;
		}

		.map-controls button:hover {
			background: rgba(75, 107, 253, 0.6);
		}

		.map-title {
			position: absolute;
			top: 8px;
			left: 8px;
			font-size: 12px;
			color: white;
			font-weight: 500;
			text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
			z-index: 1001;
		}

		/* Main UI elements */
		.potree_container {
			position: absolute;
			width: 100%;
			height: 100%;
			left: 0px;
			top: 0px;
		}
		
		/* Top view map styling */
		.top-view-map {
			position: absolute;
			right: 20px;
			bottom: 20px;
			width: 300px;
			height: 330px;
			background-color: rgba(0, 0, 0, 0.4);
			border-radius: 5px;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
			overflow: hidden;
			z-index: 100;
		}
		
		.map-title {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 30px;
			background-color: rgba(0, 0, 0, 0.7);
			line-height: 30px;
			text-align: center;
			color: white;
			font-family: Arial, sans-serif;
			font-size: 14px;
			z-index: 2;
		}
		
		.map-controls {
			position: absolute;
			top: 0;
			right: 0;
			height: 30px;
			z-index: 3;
			display: flex;
		}
		
		.map-controls button {
			border: none;
			background: transparent;
			color: white;
			width: 30px;
			height: 30px;
			cursor: pointer;
			opacity: 0.7;
			transition: opacity 0.2s;
		}
		
		.map-controls button:hover {
			opacity: 1;
		}
		
		.map-tooltip {
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			height: 30px;
			background-color: rgba(0, 0, 0, 0.7);
			line-height: 30px;
			text-align: center;
			color: white;
			font-family: Arial, sans-serif;
			font-size: 12px;
			z-index: 2;
		}

		.nav-dropdown {
			position: relative;
			display: inline-block;
		}

		.dropdown-content {
			display: none;
			position: absolute;
			background-color: #f9f9f9;
			min-width: 200px;
			box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
			z-index: 1000;
			border-radius: 4px;
		}

		.dropdown-content.show {
			display: block;
		}

		.dropdown-header {
			padding: 12px 16px;
			font-weight: bold;
			border-bottom: 1px solid #ddd;
			color: #333;
		}

		.dropdown-item {
			padding: 12px 16px;
			text-decoration: none;
			display: flex;
			align-items: center;
			color: #333;
			cursor: pointer;
			transition: background-color 0.2s;
		}

		.dropdown-item:hover {
			background-color: #f1f1f1;
		}

		.dropdown-item i {
			margin-right: 10px;
		}

		.check-icon {
			margin-left: auto;
			opacity: 0;
			transition: opacity 0.2s;
		}

		/* Test Version Ribbon */
		.test-ribbon {
			position: fixed;
			top: 20px;
			right: -50px;
			width: 200px;
			padding: 8px;
			background: #ff4d4d;
			color: white;
			text-align: center;
			font-size: 14px;
			font-weight: bold;
			transform: rotate(45deg);
			box-shadow: 0 2px 4px rgba(0,0,0,0.2);
			z-index: 1000;
		}

		.test-ribbon::before {
			content: 'TEST VERSION';
			letter-spacing: 1px;
		}

		/* Camera dropdown styles */
		.nav-dropdown-content {
			display: none;
			position: absolute;
			background: rgba(30, 35, 45, 0.95);
			backdrop-filter: blur(12px);
			border-radius: 8px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			padding: 8px;
			z-index: 1000;
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
			min-width: 120px;
		}

		.nav-dropdown-content.show {
			display: flex;
			flex-direction: row;
			gap: 8px;
		}

		.nav-dropdown-content .dropdown-item {
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 8px;
			border: none;
			background: transparent;
			color: white;
			cursor: pointer;
			border-radius: 6px;
			transition: all 0.2s ease;
		}

		.nav-dropdown-content .dropdown-item:hover {
			background: rgba(255, 255, 255, 0.1);
		}

		.nav-dropdown-content .dropdown-item i {
			font-size: 1.2em;
		}

		.nav-dropdown-content .dropdown-item.active {
			background: rgba(75, 107, 253, 0.3);
			position: relative;
		}

		.nav-dropdown-content .dropdown-item.active::after {
			content: none;
		}

		.nav-dropdown-content .dropdown-item.active i {
			color: #4B6BFD;
		}

		/* Always keep RGB view active */
		.nav-dropdown-content .dropdown-item[onclick="toggleRGBView()"] {
			background: rgba(75, 107, 253, 0.3);
		}

		.nav-dropdown-content .dropdown-item[onclick="toggleRGBView()"] i {
			color: #4B6BFD;
		}

		.potree_map_toggle {
			display: block !important;
			visibility: visible !important;
			opacity: 1 !important;
			position: relative !important;
			z-index: 1000 !important;
			transition: none !important;
		}
		
		#potree_map_toggle {
			display: block !important;
			visibility: visible !important;
			opacity: 1 !important;
			position: relative !important;
			z-index: 1000 !important;
			transition: none !important;
		}

		#potree_map_toggle.active {
			background-color: rgba(75, 107, 253, 0.3);
		}

		#potree_map {
			display: none !important;
			visibility: hidden !important;
			opacity: 0 !important;
			transition: none !important;
		}

		#potree_map.visible {
			display: block !important;
			visibility: visible !important;
			opacity: 1 !important;
		}

		/* Add styles for the viewpoints panel controls */
		.viewpoints-controls {
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.viewpoints-controls button {
			background: rgba(255, 77, 77, 0.2);
			border: none;
			border-radius: 4px;
			width: 28px;
			height: 28px;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			color: #ff6b6b;
			transition: all 0.2s ease;
		}

		.viewpoints-controls button:hover {
			background: rgba(255, 77, 77, 0.8);
			color: white;
		}

		.viewpoints-controls .close-btn {
			cursor: pointer;
			color: rgba(255, 255, 255, 0.7);
			transition: all 0.2s ease;
		}

		.viewpoints-controls .close-btn:hover {
			color: white;
		}
	</style>
</head>

<body>
	<div class="test-ribbon"></div>
	<a href="/" class="desapex-brand">
		<div class="desapex-logo">
			<div class="logo-shape">
				<svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
					<!-- Main cube shapes -->
					<path d="M50 20L80 35V65L50 80L20 65V35L50 20Z" fill="#4B6BFD" fill-opacity="0.2"/>
					<path d="M50 20L80 35L50 50L20 35L50 20Z" fill="#4B6BFD" fill-opacity="0.3"/>
					<path d="M50 50V80L20 65V35L50 50Z" fill="#4B6BFD" fill-opacity="0.4"/>
					<path d="M50 50V80L80 65V35L50 50Z" fill="#4B6BFD" fill-opacity="0.5"/>
					
					<!-- Highlight edges -->
					<path d="M50 20L80 35L50 50L20 35L50 20Z" stroke="#fff" stroke-width="2" stroke-opacity="0.5"/>
					<path d="M50 50V80L20 65V35L50 50Z" stroke="#fff" stroke-width="2" stroke-opacity="0.5"/>
					<path d="M50 50V80L80 65V35L50 50Z" stroke="#fff" stroke-width="2" stroke-opacity="0.5"/>
				</svg>
			</div>
		</div>
		<span class="brand-text">Desapex</span>
	</a>

	<script src="../libs/jquery/jquery-3.1.1.min.js"></script>
	<script src="../libs/spectrum/spectrum.js"></script>
	<script src="../libs/jquery-ui/jquery-ui.min.js"></script>
	<script src="../libs/other/BinaryHeap.js"></script>
	<script src="../libs/tween/tween.min.js"></script>
	<script src="../libs/d3/d3.js"></script>
	<script src="../libs/proj4/proj4.js"></script>
	<script src="../libs/openlayers3/ol.js"></script>
	<script src="../libs/i18next/i18next.js"></script>
	<script src="../libs/jstree/jstree.js"></script>
	<script src="../libs/three.js/build/three.min.js"></script>
	<script src="../build/potree/potree.js"></script>
	<script src="../libs/plasio/js/laslaz.js"></script>

	<script>
		document.addEventListener('DOMContentLoaded', function() {
			// Check if user is logged in
			const userEmail = localStorage.getItem('userEmail');
			if (!userEmail) {
				window.location.href = 'auth.html';
				return;
			}

			// Rest of your viewer initialization code...
		});
	</script>

	<script>
	window.onload = function(){
		// Wait for DOM to be fully loaded
		setTimeout(() => {
			// Get DOM elements
			const renderArea = document.getElementById("potree_render_area");
			if (!renderArea) {
				console.error("Render area not found");
				return;
			}
			
			// Create and initialize the viewer
			window.viewer = new Potree.Viewer(renderArea);
			
			// Basic viewer settings
			viewer.setEDLEnabled(false);
			viewer.setFOV(60);
			viewer.setPointBudget(10_000_000);
			viewer.setBackground("skybox");
			
			// Ensure orbit controls are set as default
			viewer.setControls(viewer.orbitControls);
			if (viewer.orbitControls) {
				viewer.orbitControls.enabled = true;
				viewer.orbitControls.initializeControls();
			}
			
			// Disable other controls
			if (viewer.earthControls) viewer.earthControls.enabled = false;
			if (viewer.fpControls) viewer.fpControls.enabled = false;
			if (viewer.deviceControls) viewer.deviceControls.enabled = false;
			if (viewer.vrControls) viewer.vrControls.enabled = false;
			
			// Load GUI after controls are set up
			viewer.loadGUI();
			
			// Set up performance optimizations
			viewer.setMinNodeSize(100);
			
			// Load point cloud
			Potree.loadPointCloud("../pointclouds/lion_takanawa/cloud.js", "lion", e => {
				viewer.scene.addPointCloud(e.pointcloud);
				
				// Optimize view
				let material = e.pointcloud.material;
				material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
				material.size = 1.0;
				material.pointColorType = Potree.PointColorType.RGB;
				material.pointShape = Potree.PointShape.SQUARE;
				
				// Set initial camera position
				viewer.fitToScreen();
				
				// Ensure orbit controls are active
				viewer.setControls(viewer.orbitControls);
				if (viewer.orbitControls) {
					viewer.orbitControls.enabled = true;
					viewer.orbitControls.initializeControls();
				}
			});
		}, 100);
	};

	// ... rest of the existing code ...

	// Initialize viewer
	window.onload = () => {
		// Initialize viewer
		window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
		
		// Basic viewer settings
		viewer.setEDLEnabled(true);
		viewer.setFOV(60);
		viewer.setPointBudget(5_000_000);
		viewer.loadSettingsFromURL();
		viewer.setBackground("black");

		// Set RGB view as default
		viewer.addEventListener('scene_changed', (e) => {
			e.scene.pointclouds.forEach(pointcloud => {
				if (pointcloud.material) {
					pointcloud.material.activeAttributeName = 'rgba';
					pointcloud.material.pointColorType = Potree.PointColorType.RGB;
				}
			});
		});

		// Add direct mouse wheel listener for zoom
		const renderArea = document.getElementById("potree_render_area");
		renderArea.addEventListener('wheel', (e) => {
			e.preventDefault();
			e.stopPropagation();
			
			const camera = viewer.scene.getActiveCamera();
			const zoomSpeed = 1.0;
			
			// Get camera's forward direction
			const forward = new THREE.Vector3();
			camera.getWorldDirection(forward);
			
			if (e.deltaY < 0) {
				// Zoom in - move forward
				camera.position.add(forward.multiplyScalar(zoomSpeed));
			} else {
				// Zoom out - move backward
				camera.position.sub(forward.multiplyScalar(zoomSpeed));
			}
			
			// Update view and controls
			viewer.scene.view.position.copy(camera.position);
			if (viewer.controls.target) {
				viewer.controls.target.add(forward.multiplyScalar(e.deltaY < 0 ? zoomSpeed : -zoomSpeed));
			}
		}, { passive: false });

		// Initialize controls immediately with proper settings
		viewer.loadGUI(() => {
			viewer.setLanguage('en');
			
			// Switch to first person controls for better handling
			viewer.setControls(viewer.fpControls);
			
			if (viewer.fpControls) {
				// Configure first person controls for smooth movement
				viewer.fpControls.lockElevation = false;
				viewer.fpControls.moveSpeed = 1.0;
				
				// Direct zoom implementation on render area
				const renderArea = document.getElementById('potree_render_area');
				renderArea.addEventListener('wheel', (e) => {
					e.preventDefault();
					e.stopPropagation();
					
					const camera = viewer.scene.getActiveCamera();
					const zoomSpeed = 1.0; // Increased speed for more noticeable effect
					
					// Get camera's forward direction
					const forward = new THREE.Vector3();
					camera.getWorldDirection(forward);
					
					if (e.deltaY < 0) {
						// Zoom in - move forward
						camera.position.add(forward.multiplyScalar(zoomSpeed));
					} else {
						// Zoom out - move backward
						camera.position.sub(forward.multiplyScalar(zoomSpeed));
					}
					
					// Update view and controls
					viewer.scene.view.position.copy(camera.position);
					if (viewer.controls.target) {
						viewer.controls.target.add(forward.multiplyScalar(e.deltaY < 0 ? zoomSpeed : -zoomSpeed));
					}
				}, { passive: false });

				// WASD movement
				window.addEventListener('keydown', (event) => {
					const moveSpeed = viewer.getMoveSpeed() * 0.2;
					const camera = viewer.scene.getActiveCamera();
					const direction = new THREE.Vector3();
					camera.getWorldDirection(direction);
					const right = new THREE.Vector3();
					
					switch(event.code) {
						case 'KeyW':
							camera.position.addScaledVector(direction, moveSpeed);
							viewer.controls.target.addScaledVector(direction, moveSpeed);
							break;
						case 'KeyS':
							camera.position.addScaledVector(direction, -moveSpeed);
							viewer.controls.target.addScaledVector(direction, -moveSpeed);
							break;
						case 'KeyA':
							camera.position.addScaledVector(right, -moveSpeed);
							viewer.controls.target.addScaledVector(right, -moveSpeed);
							break;
						case 'KeyD':
							camera.position.addScaledVector(right, moveSpeed);
							viewer.controls.target.addScaledVector(right, moveSpeed);
							break;
					}
					
					viewer.scene.view.position.copy(camera.position);
				});
			}

			// Hide unnecessary UI
			$('#menu_appearance').hide();
			$('#menu_about').hide();
			$('#menu_language').hide();
			$('.divider').hide();
			$('#potree_languages').remove();
		});

		// Modify the handleDrop function
		async function handleDrop(e) {
			e.preventDefault();
			const dt = e.dataTransfer;
			const files = dt.files;
			unhighlight(e);

			// Hide welcome message
			const welcomeOverlay = document.getElementById('welcomeOverlay');
			if (welcomeOverlay) {
				welcomeOverlay.style.display = 'none';
			}

			// Clear existing point clouds from the top view
			while(topViewScene.children.length > 0) {
				const obj = topViewScene.children[0];
				if (obj.geometry) obj.geometry.dispose();
				if (obj.material) obj.material.dispose();
				topViewScene.remove(obj);
			}
			
			// Re-add the basic elements
			topViewScene.add(new THREE.AmbientLight(0xffffff, 1.0));
			topViewScene.add(mapBorder);
			topViewScene.add(grid);
			topViewScene.add(cameraIndicator);

			// Progress overlay
			const progressDiv = document.createElement('div');
			progressDiv.style.position = 'fixed';
			progressDiv.style.top = '50%';
			progressDiv.style.left = '50%';
			progressDiv.style.transform = 'translate(-50%, -50%)';
			progressDiv.style.background = 'rgba(0,0,0,0.8)';
			progressDiv.style.color = 'white';
			progressDiv.style.padding = '20px';
			progressDiv.style.borderRadius = '10px';
			progressDiv.style.zIndex = '1000';
			document.body.appendChild(progressDiv);

			try {
				for (let file of files) {
					if (!file.name.toLowerCase().endsWith('.las')) {
						throw new Error('Please drop a .las file');
					}

					progressDiv.textContent = 'Loading file...';

					// Read header
					const headerBuffer = await file.slice(0, 375).arrayBuffer();
					const headerView = new DataView(headerBuffer);
					
					const pointDataFormat = headerView.getUint8(104);
					const pointDataRecordLength = headerView.getUint16(105, true);
					const numPoints = headerView.getUint32(107, true);
					const pointDataOffset = headerView.getUint32(96, true);

					// Get scale and offset
					const scaleX = headerView.getFloat64(131, true);
					const scaleY = headerView.getFloat64(139, true);
					const scaleZ = headerView.getFloat64(147, true);
					
					const offsetX = headerView.getFloat64(155, true);
					const offsetY = headerView.getFloat64(163, true);
					const offsetZ = headerView.getFloat64(171, true);

					// Optimize batch size for low memory
					const POINTS_PER_BATCH = 50000; // Smaller batches for lower memory usage
					const BATCH_BYTE_SIZE = POINTS_PER_BATCH * pointDataRecordLength;
					const totalBatches = Math.ceil(numPoints / POINTS_PER_BATCH);

					let processedPoints = 0;
					let positions = [];
					let colors = [];
					let currentGeometry = null;

					// Calculate decimation factor based on total points
					const decimationFactor = Math.max(1, Math.floor(numPoints / 2000000)); // Limit total points to ~2M

					for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
						const start = pointDataOffset + (batchIndex * BATCH_BYTE_SIZE);
						const end = Math.min(start + BATCH_BYTE_SIZE, file.size);
						
						if (start >= file.size) break;

						progressDiv.textContent = `Loading points: ${Math.round((batchIndex / totalBatches) * 100)}%`;
						
						const chunkBuffer = await file.slice(start, end).arrayBuffer();
						const dataView = new DataView(chunkBuffer);

						for (let offset = 0; offset < chunkBuffer.byteLength - pointDataRecordLength; offset += pointDataRecordLength * decimationFactor) {
							const x = dataView.getInt32(offset, true) * scaleX + offsetX;
							const y = dataView.getInt32(offset + 4, true) * scaleY + offsetY;
							const z = dataView.getInt32(offset + 8, true) * scaleZ + offsetZ;

							// Basic color handling for performance
							let r = 1.0, g = 1.0, b = 1.0;
							if (pointDataFormat >= 2) {
								const colorOffset = offset + 20;
								if (colorOffset + 6 <= chunkBuffer.byteLength) {
									r = dataView.getUint16(colorOffset, true) / 65535;
									g = dataView.getUint16(colorOffset + 2, true) / 65535;
									b = dataView.getUint16(colorOffset + 4, true) / 65535;
								}
							}

							positions.push(x, y, z);
							colors.push(r, g, b);

							processedPoints++;
							if (processedPoints >= numPoints) break;
						}

						// Create point cloud every 500K points or on last batch
						if (positions.length >= 1500000 || batchIndex === totalBatches - 1) {
							if (currentGeometry) {
								currentGeometry.dispose(); // Clean up previous geometry
							}
							
							currentGeometry = new THREE.BufferGeometry();
							currentGeometry.setAttribute(
								'position',
								new THREE.Float32BufferAttribute(positions, 3)
							);
							currentGeometry.setAttribute(
								'color',
								new THREE.Float32BufferAttribute(colors, 3)
							);

							const pointcloud = new THREE.Points(currentGeometry, pointMaterial);
							viewer.scene.scene.add(pointcloud);

							// Create a clone for the top view map with simplified material
							const topViewMaterial = new THREE.PointsMaterial({
								size: 1.5, // Increased point size for better visibility
								vertexColors: true,
								sizeAttenuation: false,
								opacity: 0.9,  // Slightly transparent to see overlapping points
								transparent: true
							});
							const topViewPointCloud = new THREE.Points(currentGeometry.clone(), topViewMaterial);
							// Add name to make it easier to identify
							topViewPointCloud.name = 'topViewPointCloud';
							topViewScene.add(topViewPointCloud);

							// Calculate bounding box of the point cloud
							currentGeometry.computeBoundingBox();
							const box = currentGeometry.boundingBox;
							const center = box.getCenter(new THREE.Vector3());
							const size = box.getSize(new THREE.Vector3());
							const maxDim = Math.max(size.x, size.y, size.z);

							// Store original bounding box info for map controls
							originalBoundingBox = box.clone();
							boxCenter = center.clone();
							boxSize = size.clone();

							// Set up top view camera - perfect top view (roof view)
							topViewCamera.left = -maxDim / 2 * initialZoomFactor;
							topViewCamera.right = maxDim / 2 * initialZoomFactor;
							topViewCamera.top = maxDim / 2 * initialZoomFactor;
							topViewCamera.bottom = -maxDim / 2 * initialZoomFactor;
							// Position camera for true top view (looking down the Z axis)
							topViewCamera.position.set(center.x, center.y, center.z + maxDim * 10);
							topViewCamera.lookAt(center);
							// Standard top view has Y as up
							topViewCamera.up.set(0, 1, 0);
							// Reset any previous rotation
							topViewCamera.rotation.set(0, 0, 0);
							topViewCamera.updateProjectionMatrix();

							// Position the map border and grid
							mapBorder.position.set(center.x, center.y, center.z);
							grid.position.set(center.x, center.y, center.z);
							grid.scale.set(maxDim/300, maxDim/300, maxDim/300);

							// Calculate a more appropriate view distance based on the model size
							// This prevents excessive zoom and maintains a good overview
							const viewDistanceFactor = 2.0; // Adjust this factor to control initial zoom level
							const initialViewDistance = maxDim * viewDistanceFactor;
							
							// Set up initial camera position for main view at a reasonable distance
							viewer.scene.view.position.set(
								center.x,
								center.y - initialViewDistance * 0.8,
								center.z + initialViewDistance * 0.5
							);

							// Look at the center of the point cloud
							viewer.scene.view.lookAt(center);

							// Don't automatically fit to screen after loading
							// viewer.fitToScreen();  // Removed to prevent excessive zoom

							// Adjust FOV for a better perspective view
							viewer.setFOV(60);
							
							// Set proper move speed based on point cloud size
							const moveSpeed = maxDim / 10;
							viewer.setMoveSpeed(moveSpeed);

							// Add or update render loop for the top view
							if (!window.topViewRenderLoopStarted) {
								window.topViewRenderLoopStarted = true;
								
								function renderTopView() {
									if (mapVisible) {
										// Update camera indicator position based on main camera
										const mainCamera = viewer.scene.getActiveCamera();
										// For top view, we place the indicator at the X,Y coordinates
										// and keep a small Z offset
										cameraIndicator.position.set(
											mainCamera.position.x,
											mainCamera.position.y,
											0.1 // Small offset to keep it above the point cloud
										);
										
										// Get camera direction
										const direction = new THREE.Vector3();
										mainCamera.getWorldDirection(direction);
										
										// For true top view, rotation is around Z axis (looking down)
										// Calculate the angle in the XY plane
										cameraIndicator.rotation.z = Math.atan2(direction.y, direction.x);
										
										// Add subtle pulsing effect to the glow circle
										const pulseFactor = 0.2 * Math.sin(Date.now() * 0.005) + 1;
										glowCircle.scale.set(pulseFactor, pulseFactor, 1);
										
										// Render the top view
										topViewRenderer.render(topViewScene, topViewCamera);
									}
									
									requestAnimationFrame(renderTopView);
								}
								
								renderTopView();
							}

							// Switch to First Person controls
							viewer.setControls(viewer.fpControls);
							if (viewer.fpControls) {
								viewer.fpControls.moveSpeed = moveSpeed;
								viewer.fpControls.lockElevation = false;
								viewer.fpControls.enableDamping = true;
								viewer.fpControls.dampingFactor = 0.05;
							}

							// Enable keyboard controls
							window.addEventListener('keydown', (event) => {
								const moveDistance = moveSpeed * 0.1;
								switch(event.code) {
									case 'KeyW':
										viewer.scene.view.position.z -= moveDistance;
										break;
									case 'KeyS':
										viewer.scene.view.position.z += moveDistance;
										break;
									case 'KeyA':
										viewer.scene.view.position.x -= moveDistance;
										break;
									case 'KeyD':
										viewer.scene.view.position.x += moveDistance;
										break;
								}
							});

							// Clear arrays
							positions = [];
							colors = [];

							// Force garbage collection and pause
							if (window.gc) window.gc();
							await new Promise(resolve => setTimeout(resolve, 10)); // Longer pause for memory cleanup
						}
					}
				}
			} catch (error) {
				console.error('Error:', error);
				alert(`Error loading file: ${error.message}`);
			} finally {
				document.body.removeChild(progressDiv);
			}
		}
		
		// Modify navigation mode function
			function setNavigation(mode) {
				if (!viewer.controls) return;
				
				switch(mode) {
				case 'flight':
					viewer.setControls(viewer.fpControls);
					if (viewer.fpControls) {
						viewer.fpControls.lockElevation = false;
						viewer.fpControls.enableDamping = true;
						viewer.fpControls.dampingFactor = 0.05;
						viewer.fpControls.moveSpeed = viewer.getMoveSpeed();
					}
					break;
					case 'orbit':
						viewer.setControls(viewer.controls);
					if (viewer.controls) {
						viewer.controls.enableRotate = true;
						viewer.controls.enableZoom = true;
						viewer.controls.enablePan = true;
						viewer.controls.enableDamping = true;
						viewer.controls.dampingFactor = 0.05;
						viewer.controls.minDistance = 0.1;
						viewer.controls.maxDistance = Infinity;
					}
						break;
					case 'earth':
							viewer.setControls(viewer.earthControls);
					if (viewer.earthControls) {
						viewer.earthControls.enableRotate = true;
						viewer.earthControls.enableZoom = true;
						viewer.earthControls.enablePan = true;
						viewer.earthControls.enableDamping = true;
						viewer.earthControls.dampingFactor = 0.05;
						viewer.earthControls.minDistance = 0.1;
						viewer.earthControls.maxDistance = Infinity;
						}
						break;
			}
		}
		
		// Handle navigation mode changes
		function setNavigation(mode) {
			if (!viewer.controls) return;
			
			switch(mode) {
				case 'orbit':
					viewer.setControls(viewer.controls);
					viewer.controls.enableRotate = true;
					viewer.controls.enableZoom = true;
					viewer.controls.enablePan = true;
					viewer.controls.autoRotate = false;
					viewer.controls.enableConstraints = false;
					break;
				case 'earth':
					if (viewer.earthControls) {
						viewer.setControls(viewer.earthControls);
						viewer.earthControls.enableConstraints = false;
						viewer.earthControls.maintainUpDirection = true;
						viewer.earthControls.enableMiddleMouseMovement = true;
						viewer.earthControls.showRotationCenter = true;
					}
					break;
				case 'flight':
					if (viewer.fpControls) {
						viewer.setControls(viewer.fpControls);
						viewer.fpControls.lockElevation = false;
						viewer.fpControls.enableConstraints = false;
					}
					break;
				case 'helicopter':
					if (viewer.fpControls) {
						viewer.setControls(viewer.fpControls);
						viewer.fpControls.lockElevation = true;
						viewer.fpControls.enableConstraints = false;
					}
					break;
				case 'panoramic':
					viewer.setControls(viewer.controls);
					viewer.scene.view.pitch = 0;
					viewer.scene.view.radius = 0;
					viewer.controls.enableConstraints = false;
					break;
			}
			
			// Update UI
			document.querySelectorAll('.dropdown-item').forEach(item => {
				item.classList.toggle('active', item.dataset.nav === mode);
			});
		}
		
		// Set up navigation dropdown
		const navToggle = document.getElementById('navToggle');
		const navDropdown = document.getElementById('navDropdown');
		let isDropdownOpen = false;
		
		navToggle.addEventListener('click', (e) => {
			e.stopPropagation();
			isDropdownOpen = !isDropdownOpen;
			navDropdown.classList.toggle('show');
		});
		
		document.querySelectorAll('.dropdown-item').forEach(item => {
			item.addEventListener('click', (e) => {
				e.stopPropagation();
				const mode = item.dataset.nav;
				setNavigation(mode);
				isDropdownOpen = false;
				navDropdown.classList.remove('show');
			});
		});
		
		document.addEventListener('click', () => {
			if (isDropdownOpen) {
				isDropdownOpen = false;
				navDropdown.classList.remove('show');
			}
		});
		
		// Handle file loading
		viewer.addEventListener('load', (e) => {
			// Don't automatically fit to screen
			// viewer.fitToScreen();  // Commented out to prevent excessive zoom
		});
		
		// Set initial navigation mode
		setNavigation('orbit');

		// Add Earth controls specific event handlers
		renderArea.addEventListener('mousedown', (e) => {
			if (viewer.earthControls && viewer.controls === viewer.earthControls) {
				// Middle mouse (scroll wheel) press handling for Earth mode
				if (e.button === 1) {
					const moveSpeed = 0.5;
					let lastX = e.clientX;
					let lastY = e.clientY;
					
					const handleMouseMove = (moveEvent) => {
						const deltaX = moveEvent.clientX - lastX;
						const deltaY = moveEvent.clientY - lastY;
						
						// Update movement direction based on mouse position
						viewer.earthControls.moveForward(deltaY * moveSpeed);
						viewer.earthControls.moveRight(deltaX * moveSpeed);
						
						lastX = moveEvent.clientX;
						lastY = moveEvent.clientY;
					};
					
					const clearMove = () => {
						window.removeEventListener('mousemove', handleMouseMove);
						window.removeEventListener('mouseup', clearMove);
					};
					
					window.addEventListener('mousemove', handleMouseMove);
					window.addEventListener('mouseup', clearMove);
				}
				
				// Right click handling for rotation point
				if (e.button === 2) {
					const point = viewer.getMousePointCloudIntersection(e.clientX, e.clientY);
					if (point) {
						viewer.earthControls.setRotationCenter(point);
					}
				}
			}
		});
	};

	// Add orthographic view toggle function
	window.toggleOrthographicView = function() {
		const button = document.querySelector('#drawDropdown .dropdown-item[onclick="toggleOrthographicView()"]');
		button.classList.toggle('active');
		
		// Toggle orthographic view functionality
		const scene = viewer.scene;
		if (scene.cameraMode === Potree.CameraMode.PERSPECTIVE) {
				viewer.setCameraMode(Potree.CameraMode.ORTHOGRAPHIC);
		} else {
				viewer.setCameraMode(Potree.CameraMode.PERSPECTIVE);
		}
	};

	window.toggleRGBView = function() {
		// RGB view is always active, just trigger the functionality
		const material = viewer.scene.pointclouds[0]?.material;
		if (material) {
			material.pointColorType = Potree.PointColorType.RGB;
			material.needsUpdate = true;
		}
	};

	// Close dropdown when clicking outside
	document.addEventListener('click', (e) => {
		if (!e.target.closest('.nav-dropdown')) {
			document.getElementById('drawDropdown').classList.remove('show');
		}
	});

	window.toggleIntensityView = () => {
		const scene = viewer.scene;
		const checkIcon = document.querySelector('.dropdown-item[onclick="toggleIntensityView()"] i.check-icon');
		const dropdownItem = document.querySelector('.dropdown-item[onclick="toggleIntensityView()"]');
		const rgbCheckIcon = document.querySelector('.dropdown-item[onclick="toggleRGBView()"] i.check-icon');
		const rgbDropdownItem = document.querySelector('.dropdown-item[onclick="toggleRGBView()"]');
		const elevationCheckIcon = document.querySelector('.dropdown-item[onclick="toggleElevationView()"] i.check-icon');
		const elevationDropdownItem = document.querySelector('.dropdown-item[onclick="toggleElevationView()"]');

		// Toggle Intensity view
		if (checkIcon.style.opacity === '0') {
			// Store current state before switching to intensity
			scene.pointclouds.forEach(pointcloud => {
				if (pointcloud.material) {
					// Store current state for restoration if needed
					if (!pointcloud._originalState && pointcloud._previousState) {
						// If we're coming from elevation mode, keep the saved state
						pointcloud._originalState = pointcloud._previousState;
						delete pointcloud._previousState;
					} else if (!pointcloud._originalState) {
						// Otherwise save current state
						pointcloud._originalState = {
							activeAttributeName: pointcloud.material.activeAttributeName,
							defines: new Map([...pointcloud.material.defines]),
							rgbWeight: pointcloud.material.weightRGB,
							intensityWeight: pointcloud.material.weightIntensity,
							elevationWeight: pointcloud.material.weightElevation
						};
					}
					
					// Clear all color type defines
					pointcloud.material.removeDefine('color_type_rgba');
					pointcloud.material.removeDefine('color_type_elevation');
					pointcloud.material.removeDefine('color_type_classification');
					pointcloud.material.removeDefine('color_type_composite');
					pointcloud.material.removeDefine('color_type_matcap');
					
					// Set pure intensity coloring
					pointcloud.material.setDefine('color_type_intensity', true);
					pointcloud.material.activeAttributeName = 'intensity';
					
					// Set weights for intensity view
					pointcloud.material.weightRGB = 0.0;
					pointcloud.material.weightIntensity = 1.0;
					pointcloud.material.weightElevation = 0.0;
					
					// Force material update
					pointcloud.material.needsUpdate = true;
					
					// Update all underlying octree nodes
					if (pointcloud.visibleNodes) {
						for (const node of pointcloud.visibleNodes) {
							if (node.sceneNode) {
								node.sceneNode.material = pointcloud.material;
							}
						}
					}
				}
			});
			
			// Update UI
			checkIcon.style.opacity = '1';
			dropdownItem.classList.add('active');
			
			// Disable RGB and elevation views
			rgbCheckIcon.style.opacity = '0';
			rgbDropdownItem.classList.remove('active');
			elevationCheckIcon.style.opacity = '0';
			elevationDropdownItem.classList.remove('active');
		} else {
			// Switch back to RGB view
			scene.pointclouds.forEach(pointcloud => {
				if (pointcloud.material) {
					// Restore original state if available
					if (pointcloud._originalState) {
						// Restore defines from original state
						pointcloud.material.defines.clear();
						for (const [key, value] of pointcloud._originalState.defines) {
							pointcloud.material.defines.set(key, value);
						}
						
						// Restore active attribute and weights
						pointcloud.material.activeAttributeName = pointcloud._originalState.activeAttributeName;
						pointcloud.material.weightRGB = pointcloud._originalState.rgbWeight;
						pointcloud.material.weightIntensity = pointcloud._originalState.intensityWeight;
						pointcloud.material.weightElevation = pointcloud._originalState.elevationWeight;
						
						// Clean up saved state
						delete pointcloud._originalState;
					} else {
						// Default to RGB view
						pointcloud.material.removeDefine('color_type_intensity');
						pointcloud.material.setDefine('color_type_rgba', true);
						pointcloud.material.activeAttributeName = 'rgba';
						pointcloud.material.weightRGB = 1.0;
						pointcloud.material.weightIntensity = 0.0;
						pointcloud.material.weightElevation = 0.0;
					}
					
					// Force material update
					pointcloud.material.needsUpdate = true;
					
					// Update all underlying octree nodes
					if (pointcloud.visibleNodes) {
						for (const node of pointcloud.visibleNodes) {
							if (node.sceneNode) {
								node.sceneNode.material = pointcloud.material;
							}
						}
					}
				}
			});
			
			// Update UI
			checkIcon.style.opacity = '0';
			dropdownItem.classList.remove('active');
			rgbCheckIcon.style.opacity = '1';
			rgbDropdownItem.classList.add('active');
		}

		// Force material update for all pointclouds
		viewer.scene.dispatchEvent({
			type: 'material_property_changed',
			target: scene.pointclouds[0]?.material
		});
		
		// Force renderer to update
		viewer.renderArea.style.opacity = '0.99';
		setTimeout(() => {
			viewer.renderArea.style.opacity = '1.0';
		}, 20);
	};

	window.toggleElevationView = () => {
		const scene = viewer.scene;
		const checkIcon = document.querySelector('.dropdown-item[onclick="toggleElevationView()"] i.check-icon');
		const dropdownItem = document.querySelector('.dropdown-item[onclick="toggleElevationView()"]');
		const rgbCheckIcon = document.querySelector('.dropdown-item[onclick="toggleRGBView()"] i.check-icon');
		const rgbDropdownItem = document.querySelector('.dropdown-item[onclick="toggleRGBView()"]');
		const intensityCheckIcon = document.querySelector('.dropdown-item[onclick="toggleIntensityView()"] i.check-icon');
		const intensityDropdownItem = document.querySelector('.dropdown-item[onclick="toggleIntensityView()"]');

		// Toggle Elevation view
		if (checkIcon.style.opacity === '0') {
			scene.pointclouds.forEach(pointcloud => {
				if (pointcloud.material) {
					try {
						// Store current state for restoration
						if (!pointcloud._previousState) {
							pointcloud._previousState = {
								activeAttributeName: pointcloud.material.activeAttributeName,
								defines: new Map([...pointcloud.material.defines]),
								rgbWeight: pointcloud.material.weightRGB,
								intensityWeight: pointcloud.material.weightIntensity,
								elevationWeight: pointcloud.material.weightElevation
							};
						}

						// Clear all previous material states
						pointcloud.material.defines.clear();
						
						// Remove all color types
						pointcloud.material.removeDefine('color_type_rgba');
						pointcloud.material.removeDefine('color_type_intensity');
						pointcloud.material.removeDefine('color_type_classification');
						pointcloud.material.removeDefine('color_type_elevation');
						pointcloud.material.removeDefine('color_type_height');
						pointcloud.material.removeDefine('color_type_matcap');
						
						// Enable composite coloring mode
						pointcloud.material.setDefine('color_type_composite', true);
						
						// Update elevation range based on point cloud bounding box
						let box = pointcloud.getBoundingBoxWorld();
						
						pointcloud.updateMatrixWorld(true);
						box = Utils.computeTransformedBoundingBox(box, pointcloud.matrixWorld);
						
						let bWidth = box.max.z - box.min.z;
						let heightMin = box.min.z - 0.2 * bWidth;
						let heightMax = box.max.z + 0.2 * bWidth;
						
						// Set elevation range and gradient
						pointcloud.material.elevationRange = [heightMin, heightMax];
						pointcloud.material.gradient = Potree.Gradients.SPECTRAL;
						
						// Set weights for pure elevation view using composite mode
						pointcloud.material.weightRGB = 0.0;
						pointcloud.material.weightIntensity = 0.0;
						pointcloud.material.weightElevation = 1.0;
						pointcloud.material.weightClassification = 0.0;
						
						// Force material update
						pointcloud.material.needsUpdate = true;
						
						// Update all underlying octree nodes
						if (pointcloud.visibleNodes) {
							for (const node of pointcloud.visibleNodes) {
								if (node.sceneNode) {
									node.sceneNode.material = pointcloud.material;
								}
							}
						}
						
						// Update check icons
						checkIcon.style.opacity = '1';
						dropdownItem.classList.add('active');
						rgbCheckIcon.style.opacity = '0';
						rgbDropdownItem.classList.remove('active');
						intensityCheckIcon.style.opacity = '0';
						intensityDropdownItem.classList.remove('active');
						
						// Force immediate render
						viewer.scene.requestRender();
						
					} catch (error) {
						console.error('Error applying elevation view:', error);
					}
				}
			});
		} else {
			// Restore previous view
			scene.pointclouds.forEach(pointcloud => {
				if (pointcloud.material && pointcloud._previousState) {
					// Restore previous state
					pointcloud.material.defines = new Map([...pointcloud._previousState.defines]);
					pointcloud.material.activeAttributeName = pointcloud._previousState.activeAttributeName;
					pointcloud.material.weightRGB = pointcloud._previousState.rgbWeight;
					pointcloud.material.weightIntensity = pointcloud._previousState.intensityWeight;
					pointcloud.material.weightElevation = pointcloud._previousState.elevationWeight;
					
					// Clean up saved state
					delete pointcloud._previousState;
					
					// Force material update
					pointcloud.material.needsUpdate = true;
					
					// Update all underlying octree nodes
					if (pointcloud.visibleNodes) {
						for (const node of pointcloud.visibleNodes) {
							if (node.sceneNode) {
								node.sceneNode.material = pointcloud.material;
							}
						}
					}
				}
			});
			
			// Update UI
			checkIcon.style.opacity = '0';
			dropdownItem.classList.remove('active');
			rgbCheckIcon.style.opacity = '1';
			rgbDropdownItem.classList.add('active');
		}

		// Force material update for all pointclouds
		viewer.scene.dispatchEvent({
			type: 'material_property_changed',
			target: scene.pointclouds[0]?.material
		});
		
		// Force immediate render
		viewer.scene.requestRender();
		
		// Force multiple renders to ensure update
		viewer.renderArea.style.opacity = '0.99';
		setTimeout(() => {
			viewer.renderArea.style.opacity = '1.0';
			viewer.scene.requestRender();
		}, 20);
		
		// Additional render to ensure changes are applied
		setTimeout(() => {
			viewer.scene.requestRender();
		}, 100);
	};

	window.toggleTransform = function() {
		const button = document.querySelector('[title="Zoomed in view"]');
		button.classList.toggle('active');
		
		// Get all point clouds and their bounds
		const box = viewer.getBoundingBox(viewer.scene.pointclouds);
		const size = box.getSize(new THREE.Vector3());
		const center = box.getCenter(new THREE.Vector3());
		const maxDim = Math.max(size.x, size.y, size.z);
		
		// Set to perspective mode for panoramic view
		viewer.setCameraMode(1);  // PERSPECTIVE
		
		// Position camera at an elevated angle for panoramic view
		const distance = maxDim * 1.5;  // Closer distance for better detail
		viewer.scene.view.position.set(
			center.x - distance,  // Position camera diagonally for panoramic view
			center.y - distance,
			center.z + distance * 0.75  // Slightly lower height for better perspective
		);
		
		// Set view parameters for panoramic angle
		viewer.scene.view.pitch = -Math.PI / 6;  // -30 degrees for panoramic angle
		viewer.scene.view.yaw = Math.PI / 4;     // 45 degrees rotation for diagonal view
		viewer.scene.view.radius = distance;
		
		// Set a wider field of view for panoramic effect
		viewer.setFOV(75);
		
		// Ensure the entire point cloud is visible
		viewer.fitToScreen();
	};

		function toggleFullscreenView() {
			if (document.fullscreenElement) {
				document.exitFullscreen();
			} else {
				document.documentElement.requestFullscreen();
			}
		}

		// Initialize savedViewpoints only once
		let savedViewpoints = localStorage.getItem('savedViewpoints') 
			? JSON.parse(localStorage.getItem('savedViewpoints')).map(vp => ({
				...vp,
				position: new THREE.Vector3(vp.position.x, vp.position.y, vp.position.z),
				target: new THREE.Vector3(vp.target.x, vp.target.y, vp.target.z)
			}))
			: [];

		window.showSaveViewpointDialog = function() {
			const dialog = document.getElementById('saveViewpointDialog');
			dialog.style.display = 'block';
			document.getElementById('viewpointName').value = '';
			document.getElementById('viewpointName').focus();
		};

		window.closeSaveViewpointDialog = function(event) {
			if (event) {
				event.preventDefault();
				event.stopPropagation();
			}
			
			// Remove console.log
			const dialog = document.getElementById('saveViewpointDialog');
			if (dialog) {
				dialog.style.display = 'none';
			}
			return false;
		};

		window.saveViewpoint = function() {
			const name = document.getElementById('viewpointName').value.trim();
			if (!name) {
				alert('Please enter a name for the viewpoint');
				return;
			}

			const camera = viewer.scene.getActiveCamera();
			const viewpoint = {
				id: Date.now(),
				name: name,
				position: camera.position.clone(),
				target: viewer.scene.view.position.clone(),
				timestamp: new Date().toLocaleString()
			};

			savedViewpoints.push(viewpoint);
			updateViewpointsList();
			closeSaveViewpointDialog();
			toggleViewpointsPanel(true);

			// Save to localStorage
			localStorage.setItem('savedViewpoints', JSON.stringify(savedViewpoints));
		};

		window.toggleViewpointsPanel = function(show) {
			const panel = document.getElementById('savedViewpointsPanel');
			panel.style.display = show ? 'block' : 'none';
		};

		window.loadViewpoint = function(viewpoint) {
			const camera = viewer.scene.getActiveCamera();
			
			// Create a smooth transition
			const duration = 1000; // 1 second
			const startPos = camera.position.clone();
			const startTarget = viewer.scene.view.position.clone();
			const startTime = Date.now();

			function animate() {
				const elapsed = Date.now() - startTime;
				const progress = Math.min(elapsed / duration, 1);
				
				// Use easing function for smooth transition
				const eased = 1 - Math.pow(1 - progress, 3);

				camera.position.lerpVectors(startPos, viewpoint.position, eased);
				viewer.scene.view.position.lerpVectors(startTarget, viewpoint.target, eased);
				
				if (progress < 1) {
					requestAnimationFrame(animate);
				}
			}

			animate();
		};

		window.deleteViewpoint = function(id, event) {
			if (event) {
				event.stopPropagation();
			}
			
			// Convert to let if it was const before
			let savedViewpointsVar = window.savedViewpoints || savedViewpoints;
			
			// Filter out the viewpoint with the given id
			savedViewpointsVar = savedViewpointsVar.filter(vp => vp.id !== id);
			
			// Update global references
			if (window.savedViewpoints) window.savedViewpoints = savedViewpointsVar;
			savedViewpoints = savedViewpointsVar;
			
			// Update the UI
			updateViewpointsList();
			
			// Save to localStorage
			localStorage.setItem('savedViewpoints', JSON.stringify(savedViewpointsVar));
			
			return false; // Prevent any other handlers from executing
		};

		function updateViewpointsList() {
			const list = document.getElementById('viewpointList');
			if (!list) return;
			
			list.innerHTML = '';
			
			let viewpointsToDisplay = window.savedViewpoints || savedViewpoints;
			if (!viewpointsToDisplay || !Array.isArray(viewpointsToDisplay)) {
				console.error("No viewpoints array found");
				return;
			}

			viewpointsToDisplay.forEach(viewpoint => {
				// Create main container
				const item = document.createElement('div');
				item.className = 'viewpoint-item';
				
				// Create name span
				const nameSpan = document.createElement('span');
				nameSpan.textContent = viewpoint.name;
				nameSpan.style.flexGrow = '1';
				item.appendChild(nameSpan);
				
				// Create container for the delete button to isolate it from the item click
				const btnContainer = document.createElement('div');
				btnContainer.style.position = 'relative';
				btnContainer.style.zIndex = '20';
				
				// Create delete button with better handling
				const deleteBtn = document.createElement('button');
				deleteBtn.className = 'delete-btn';
				deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
				deleteBtn.title = 'Delete viewpoint';
				
				// Use direct event handler
				deleteBtn.addEventListener('click', function(e) {
					e.stopPropagation();
					e.preventDefault();
					
					// Remove console.log
					
					try {
						// Delete the viewpoint - do a direct localStorage update first
						const currentViewpoints = JSON.parse(localStorage.getItem('savedViewpoints') || '[]');
						const updatedViewpoints = currentViewpoints.filter(vp => vp.id !== viewpoint.id);
						localStorage.setItem('savedViewpoints', JSON.stringify(updatedViewpoints));
						
						// Update window global regardless of scope
						window.savedViewpoints = updatedViewpoints.map(vp => ({
							...vp,
							position: new THREE.Vector3(vp.position.x, vp.position.y, vp.position.z),
							target: new THREE.Vector3(vp.target.x, vp.target.y, vp.target.z)
						}));
						
						// Try to update local variable safely if it exists in this scope
						if (typeof savedViewpoints !== 'undefined') {
							try {
								// Try/catch in case it's a const
								savedViewpoints = window.savedViewpoints;
							} catch (e) {
								// Remove console.log
							}
						}
						
						// Update UI directly instead of through updateViewpointsList to avoid const issues
						e.target.closest('.viewpoint-item').remove();
						
						// Remove console.log
					} catch (error) {
						console.error('Error deleting viewpoint:', error);
					}
					
					return false;
				});
				
				btnContainer.appendChild(deleteBtn);
				item.appendChild(btnContainer);
				
				// Add click handler to load viewpoint (only for the item, not the delete button)
				item.addEventListener('click', function(e) {
					if (!e.target.closest('.delete-btn')) {
						window.loadViewpoint(viewpoint);
					}
				});
				
				list.appendChild(item);
			});
		}

		// Load saved viewpoints from localStorage on startup
		document.addEventListener('DOMContentLoaded', () => {
			const saved = localStorage.getItem('savedViewpoints');
			if (saved) {
				savedViewpoints = JSON.parse(saved);
				savedViewpoints.forEach(vp => {
					vp.position = new THREE.Vector3(vp.position.x, vp.position.y, vp.position.z);
					vp.target = new THREE.Vector3(vp.target.x, vp.target.y, vp.target.z);
				});
				updateViewpointsList();
			}
		});

		window.toggleCameraMenu = function(event) {
			event.stopPropagation();
			const dropdown = document.getElementById('cameraDropdown');
			dropdown.classList.toggle('show');
			
			// Close dropdown when clicking outside
			const closeDropdown = (e) => {
				if (!e.target.closest('.nav-dropdown')) {
					dropdown.classList.remove('show');
					document.removeEventListener('click', closeDropdown);
				}
			};
			
			document.addEventListener('click', closeDropdown);
		};

		window.handleCameraOption = function(option) {
			switch(option) {
				case 'screenshot':
					takeScreenshot();
					break;
				case 'pov':
					showSaveViewpointDialog();
					break;
			}
			
			document.getElementById('cameraDropdown').classList.remove('show');
		};

		window.takeScreenshot = function() {
			const dialog = document.getElementById('screenshotDialog');
			dialog.style.display = 'block';
		};

		window.closeScreenshotDialog = function() {
			const dialog = document.getElementById('screenshotDialog');
			dialog.style.display = 'none';
		};

		window.takeScreenshotWithResolution = async function() {
			const button = document.querySelector('[title="Camera"]');
			button.classList.add('active');
			
			const resolutionStr = document.getElementById('resolutionSelect').value;
			let width, height;
			
			if (resolutionStr === 'current') {
				width = viewer.renderer.domElement.width;
				height = viewer.renderer.domElement.height;
			} else {
				[width, height] = resolutionStr.split('x').map(Number);
			}
			
			try {
				// Save current canvas size
				const originalWidth = viewer.renderer.domElement.width;
				const originalHeight = viewer.renderer.domElement.height;
				
				// Temporarily resize renderer
				viewer.renderer.setSize(width, height);
				
				// Force a render at new size
				viewer.renderer.render(viewer.scene.scene, viewer.scene.getActiveCamera());
				
				// Take screenshot
				const screenshot = viewer.renderer.domElement.toDataURL('image/png');
				
				// Create temporary link to download
				const link = document.createElement('a');
				link.href = screenshot;
				link.download = `screenshot_${width}x${height}.png`;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				
				// Restore original size
				viewer.renderer.setSize(originalWidth, originalHeight);
				viewer.renderer.render(viewer.scene.scene, viewer.scene.getActiveCamera());
				
				button.classList.remove('active');
				closeScreenshotDialog();
			} catch (error) {
				console.error('Screenshot error:', error);
				alert('Failed to take screenshot. Please try again.');
				button.classList.remove('active');
				closeScreenshotDialog();
			}
		};

		// Close dialog when clicking outside
		document.addEventListener('click', function(event) {
			const dialog = document.getElementById('screenshotDialog');
			if (event.target === dialog) {
				closeScreenshotDialog();
			}
		});

		window.startVideoAnimation = function() {
			const animation = new Potree.CameraAnimation(viewer);
			animation.setVisible(true);
			viewer.scene.cameraAnimations.push(animation);
		};

		window.startObjectAnimation = function() {
			// Create an orbit animation around the current target
			const camera = viewer.scene.getActiveCamera();
			const target = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(100));
			
			const animation = new Potree.CameraAnimation(viewer);
			animation.setVisible(true);
			
			// Add control points for a circular path
			const radius = 100;
			const points = 8;
			for(let i = 0; i <= points; i++) {
				const angle = (i / points) * Math.PI * 2;
				const x = target.x + radius * Math.cos(angle);
				const z = target.z + radius * Math.sin(angle);
				const position = new THREE.Vector3(x, target.y, z);
				
				animation.addControlPoint({
					position: position,
					target: target
				});
			}
			
			viewer.scene.cameraAnimations.push(animation);
		};

		

		// Drawing Tools Functions
		function toggleDraw() {
			const button = document.querySelector('[title="Draw"]');
			button.classList.toggle('active');
			// Add drawing mode toggle here
		}

		// Make functions globally accessible
		window.toggleTransform = function() {
			const button = document.querySelector('[title="Zoomed in view"]');
			button.classList.toggle('active');
			
			// Get all point clouds and their bounds
			const box = viewer.getBoundingBox(viewer.scene.pointclouds);
			const size = box.getSize(new THREE.Vector3());
			const center = box.getCenter(new THREE.Vector3());
			const maxDim = Math.max(size.x, size.y, size.z);
			
			// Set to perspective mode for panoramic view
			viewer.setCameraMode(1);  // PERSPECTIVE
			
			// Position camera at an elevated angle for panoramic view
			const distance = maxDim * 1.5;  // Closer distance for better detail
			viewer.scene.view.position.set(
				center.x - distance,  // Position camera diagonally for panoramic view
				center.y - distance,
				center.z + distance * 0.75  // Slightly lower height for better perspective
			);
			
			// Set view parameters for panoramic angle
			viewer.scene.view.pitch = -Math.PI / 6;  // -30 degrees for panoramic angle
			viewer.scene.view.yaw = Math.PI / 4;     // 45 degrees rotation for diagonal view
			viewer.scene.view.radius = distance;
			
			// Set a wider field of view for panoramic effect
			viewer.setFOV(75);
			
			// Ensure the entire point cloud is visible
			viewer.fitToScreen();
		};

		window.toggleFullscreenView = function() {
			const button = document.querySelector('[title="Fullscreen View"]');
			button.classList.toggle('active');
			
			const renderArea = document.getElementById('potree_render_area');
			const container = document.querySelector('.potree_container');
			const dropZone = document.getElementById('dropZone');
			const welcomeOverlay = document.getElementById('welcomeOverlay');
			
			// Function to handle fullscreen changes
			function onFullscreenChange() {
				if (document.fullscreenElement) {
					// Update viewer size for fullscreen
					viewer.setDimensions(window.innerWidth, window.innerHeight);
					viewer.renderer.setSize(window.innerWidth, window.innerHeight);
					
					// Ensure container covers full screen
					container.style.width = '100vw';
					container.style.height = '100vh';
					container.style.position = 'fixed';
					container.style.left = '0';
					container.style.top = '0';
					
					// Update drop zone for fullscreen
					if (dropZone) {
						dropZone.style.position = 'fixed';
						dropZone.style.width = '100vw';
						dropZone.style.height = '100vh';
						dropZone.style.left = '0';
						dropZone.style.top = '0';
						dropZone.style.zIndex = '10000';
					}
					
					// Update welcome overlay for fullscreen
					if (welcomeOverlay) {
						welcomeOverlay.style.position = 'fixed';
						welcomeOverlay.style.zIndex = '10001';
					}
					
					// Ensure the minimal-nav stays on top
					const minimalNav = document.querySelector('.minimal-nav');
					if (minimalNav) {
						minimalNav.style.zIndex = '10002';
					}
					
				} else {
					// Restore original size
					viewer.setDimensions(renderArea.clientWidth, renderArea.clientHeight);
					viewer.renderer.setSize(renderArea.clientWidth, renderArea.clientHeight);
					
					// Restore container size
					container.style.width = '100%';
					container.style.height = '100%';
					container.style.position = 'absolute';
					
					// Restore drop zone
					if (dropZone) {
						dropZone.style.position = 'fixed';
						dropZone.style.width = '100%';
						dropZone.style.height = '100%';
						dropZone.style.zIndex = '1000';
					}
					
					// Restore welcome overlay
					if (welcomeOverlay) {
						welcomeOverlay.style.position = 'fixed';
						welcomeOverlay.style.zIndex = '999';
					}
					
					// Restore minimal-nav z-index
					const minimalNav = document.querySelector('.minimal-nav');
					if (minimalNav) {
						minimalNav.style.zIndex = '1000';
					}
				}
				
				// Force a re-render
				viewer.renderer.render(viewer.scene.scene, viewer.scene.getActiveCamera());
			}

			// Add fullscreen change event listeners
			document.addEventListener('fullscreenchange', onFullscreenChange);
			document.addEventListener('webkitfullscreenchange', onFullscreenChange);
			document.addEventListener('mozfullscreenchange', onFullscreenChange);
			document.addEventListener('MSFullscreenChange', onFullscreenChange);
			
			if (!document.fullscreenElement) {
				// Enter fullscreen
				if (container.requestFullscreen) {
					container.requestFullscreen();
				} else if (container.webkitRequestFullscreen) { // Safari
					container.webkitRequestFullscreen();
				} else if (container.msRequestFullscreen) { // IE11
					container.msRequestFullscreen();
				}
			} else {
				// Exit fullscreen
				if (document.exitFullscreen) {
					document.exitFullscreen();
				} else if (document.webkitExitFullscreen) { // Safari
					document.webkitExitFullscreen();
				} else if (document.msExitFullscreen) { // IE11
					document.msExitFullscreen();
				}
			}
		};

		window.showSaveViewpointDialog = function() {
			const dialog = document.getElementById('saveViewpointDialog');
			dialog.style.display = 'block';
			document.getElementById('viewpointName').value = '';
			document.getElementById('viewpointName').focus();
		};

		window.closeSaveViewpointDialog = function(event) {
			if (event) {
				event.preventDefault();
				event.stopPropagation();
			}
			
			// Remove console.log
			const dialog = document.getElementById('saveViewpointDialog');
			if (dialog) {
				dialog.style.display = 'none';
			}
			return false;
		};

		window.saveViewpoint = function() {
			const name = document.getElementById('viewpointName').value.trim();
			if (!name) {
				alert('Please enter a name for the viewpoint');
				return;
			}

			const camera = viewer.scene.getActiveCamera();
			const viewpoint = {
				id: Date.now(),
				name: name,
				position: camera.position.clone(),
				target: viewer.scene.view.position.clone(),
				timestamp: new Date().toLocaleString()
			};

			savedViewpoints.push(viewpoint);
			updateViewpointsList();
			closeSaveViewpointDialog();
			toggleViewpointsPanel(true);

			// Save to localStorage
			localStorage.setItem('savedViewpoints', JSON.stringify(savedViewpoints));
		};

		window.toggleViewpointsPanel = function(show) {
			const panel = document.getElementById('savedViewpointsPanel');
			panel.style.display = show ? 'block' : 'none';
		};

		window.loadViewpoint = function(viewpoint) {
			const camera = viewer.scene.getActiveCamera();
			
			// Create a smooth transition
			const duration = 1000; // 1 second
			const startPos = camera.position.clone();
			const startTarget = viewer.scene.view.position.clone();
			const startTime = Date.now();

			function animate() {
				const elapsed = Date.now() - startTime;
				const progress = Math.min(elapsed / duration, 1);
				
				// Use easing function for smooth transition
				const eased = 1 - Math.pow(1 - progress, 3);

				camera.position.lerpVectors(startPos, viewpoint.position, eased);
				viewer.scene.view.position.lerpVectors(startTarget, viewpoint.target, eased);
				
				if (progress < 1) {
					requestAnimationFrame(animate);
				}
			}

			animate();
		};

		window.deleteViewpoint = function(id, event) {
			if (event) {
				event.stopPropagation();
			}
			
			// Convert to let if it was const before
			let savedViewpointsVar = window.savedViewpoints || savedViewpoints;
			
			// Filter out the viewpoint with the given id
			savedViewpointsVar = savedViewpointsVar.filter(vp => vp.id !== id);
			
			// Update global references
			if (window.savedViewpoints) window.savedViewpoints = savedViewpointsVar;
			savedViewpoints = savedViewpointsVar;
			
			// Update the UI
			updateViewpointsList();
			
			// Save to localStorage
			localStorage.setItem('savedViewpoints', JSON.stringify(savedViewpointsVar));
			
			return false; // Prevent any other handlers from executing
		};

		function updateViewpointsList() {
			const list = document.getElementById('viewpointList');
			if (!list) return;
			
			list.innerHTML = '';
			
			let viewpointsToDisplay = window.savedViewpoints || savedViewpoints;
			if (!viewpointsToDisplay || !Array.isArray(viewpointsToDisplay)) {
				console.error("No viewpoints array found");
				return;
			}

			viewpointsToDisplay.forEach(viewpoint => {
				// Create main container
				const item = document.createElement('div');
				item.className = 'viewpoint-item';
				
				// Create name span
				const nameSpan = document.createElement('span');
				nameSpan.textContent = viewpoint.name;
				nameSpan.style.flexGrow = '1';
				item.appendChild(nameSpan);
				
				// Create container for the delete button to isolate it from the item click
				const btnContainer = document.createElement('div');
				btnContainer.style.position = 'relative';
				btnContainer.style.zIndex = '20';
				
				// Create delete button with better handling
				const deleteBtn = document.createElement('button');
				deleteBtn.className = 'delete-btn';
				deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
				deleteBtn.title = 'Delete viewpoint';
				
				// Use direct event handler
				deleteBtn.addEventListener('click', function(e) {
					e.stopPropagation();
					e.preventDefault();
					
					// Remove console.log
					
					try {
						// Delete the viewpoint - do a direct localStorage update first
						const currentViewpoints = JSON.parse(localStorage.getItem('savedViewpoints') || '[]');
						const updatedViewpoints = currentViewpoints.filter(vp => vp.id !== viewpoint.id);
						localStorage.setItem('savedViewpoints', JSON.stringify(updatedViewpoints));
						
						// Update window global regardless of scope
						window.savedViewpoints = updatedViewpoints.map(vp => ({
							...vp,
							position: new THREE.Vector3(vp.position.x, vp.position.y, vp.position.z),
							target: new THREE.Vector3(vp.target.x, vp.target.y, vp.target.z)
						}));
						
						// Try to update local variable safely if it exists in this scope
						if (typeof savedViewpoints !== 'undefined') {
							try {
								// Try/catch in case it's a const
								savedViewpoints = window.savedViewpoints;
							} catch (e) {
								// Remove console.log
							}
						}
						
						// Update UI directly instead of through updateViewpointsList to avoid const issues
						e.target.closest('.viewpoint-item').remove();
						
						// Remove console.log
					} catch (error) {
						console.error('Error deleting viewpoint:', error);
					}
					
					return false;
				});
				
				btnContainer.appendChild(deleteBtn);
				item.appendChild(btnContainer);
				
				// Add click handler to load viewpoint (only for the item, not the delete button)
				item.addEventListener('click', function(e) {
					if (!e.target.closest('.delete-btn')) {
						window.loadViewpoint(viewpoint);
					}
				});
				
				list.appendChild(item);
			});
		}

		// Load saved viewpoints from localStorage on startup
		document.addEventListener('DOMContentLoaded', () => {
			const saved = localStorage.getItem('savedViewpoints');
			if (saved) {
				savedViewpoints = JSON.parse(saved);
				savedViewpoints.forEach(vp => {
					vp.position = new THREE.Vector3(vp.position.x, vp.position.y, vp.position.z);
					vp.target = new THREE.Vector3(vp.target.x, vp.target.y, vp.target.z);
				});
				updateViewpointsList();
			}
		});

		// Add a direct event listener to the cancel button
		document.addEventListener('DOMContentLoaded', function() {
			const cancelButton = document.querySelector('#saveViewpointDialog .cancel');
			if (cancelButton) {
				cancelButton.addEventListener('click', function(e) {
					e.preventDefault();
					e.stopPropagation();
					window.closeSaveViewpointDialog(e);
					return false;
				});
			}
		});
	</script>
	
	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; overflow: hidden;">
		<div id="potree_render_area" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></div>
		<div id="top_view_map" class="top-view-map" style="display: none;">
			<div class="map-title">Top View</div>
			<div class="map-controls">
				<button id="zoomInMap" title="Zoom In"><i class="fas fa-plus"></i></button>
				<button id="zoomOutMap" title="Zoom Out"><i class="fas fa-minus"></i></button>
				<button id="resetMap" title="Reset View"><i class="fas fa-sync-alt"></i></button>
				<button id="closeMap" title="Close Map"><i class="fas fa-times"></i></button>
			</div>
			<div class="map-tooltip">Click on any point to navigate to that location</div>
		</div>
		
		<!-- Welcome Message Overlay -->
		<div class="welcome-overlay" id="welcomeOverlay">
			<i class="fas fa-cloud-upload-alt"></i>
			<h2>Welcome to Potree Viewer</h2>
			<p>To get started, simply drag and drop your LAS file anywhere into this viewer.</p>
			<div class="dismiss" onclick="document.getElementById('welcomeOverlay').style.display='none'">
				<i class="fas fa-times"></i>
			</div>
		</div>
		<div class="minimal-nav">
			<div class="nav-dropdown">
				<!-- Removed navigation mode icon and dropdown -->
			</div>
			<!-- Camera Dropdown -->
			<div class="nav-dropdown">
				<button class="nav-button" title="Camera" onclick="toggleCameraMenu(event)">
					<i class="fas fa-camera"></i>
				</button>
				<div class="nav-dropdown-content" id="cameraDropdown">
					<button class="dropdown-item" onclick="handleCameraOption('screenshot')" title="Take Screenshot">
						<i class="fas fa-camera"></i>
					</button>
					<button class="dropdown-item" onclick="handleCameraOption('pov')" title="Save Point of View">
						<i class="fas fa-eye"></i>
					</button>
				</div>
			</div>

			<div class="nav-separator"></div>

			<!-- Drawing Tools -->
			<div class="nav-dropdown">
				<button class="nav-button" id="drawToggle" title="Draw">
					<i class="fas fa-pencil-alt"></i>
				</button>
				<div class="nav-dropdown-content" id="drawDropdown">
					<button class="dropdown-item" onclick="toggleOrthographicView()" title="Orthographic View">
						<i class="fas fa-cube"></i>
					</button>
					<button class="dropdown-item active" onclick="toggleRGBView()" title="RGB View">
						<i class="fas fa-palette"></i>
					</button>
				</div>
			</div>
			
			<!-- Map Button -->
			<button class="nav-button" title="Top View Map" id="mapButton">
				<i class="fas fa-map"></i>
			</button>
			
			<button class="nav-button" title="Zoomed in view" onclick="toggleTransform()">
				<i class="fas fa-arrows-alt"></i>
			</button>
			
			<button class="nav-button" title="Fullscreen View" onclick="toggleFullscreenView()">
				<i class="fas fa-expand-arrows-alt"></i>
			</button>
		</div>
	</div>

	<div class="drop-zone" id="dropZone">
		<div class="drop-zone-text">Drop LAS file here</div>
	</div>
	
	<div class="screenshot-dialog" id="screenshotDialog">
		<h3>Export Snapshot</h3>
		<select id="resolutionSelect">
			<option value="1920x1080">1920 × 1080 (Full HD)</option>
			<option value="2560x1440">2560 × 1440 (2K)</option>
			<option value="3840x2160">3840 × 2160 (4K)</option>
			<option value="current">Current Window Size</option>
		</select>
		<div class="buttons">
			<button class="cancel" onclick="closeScreenshotDialog()">Cancel</button>
			<button class="take-screenshot" onclick="takeScreenshotWithResolution()">Screenshot</button>
		</div>
	</div>
	
	<div class="saved-viewpoints-panel" id="savedViewpointsPanel">
		<h3>
			Saved Viewpoints
			<div class="viewpoints-controls">
				<button id="clearAllViewpoints" title="Clear All Viewpoints">
					<i class="fas fa-trash"></i>
				</button>
				<i class="fas fa-times close-btn" onclick="toggleViewpointsPanel(false)" title="Close"></i>
			</div>
		</h3>
		<div class="viewpoint-list" id="viewpointList">
			<!-- Viewpoints will be added here dynamically -->
		</div>
	</div>

	<div class="save-viewpoint-dialog" id="saveViewpointDialog">
		<h3>Save Viewpoint</h3>
		<input type="text" id="viewpointName" placeholder="Enter viewpoint name">
		<div class="buttons">
			<button type="button" class="cancel" id="cancelViewpointBtn">Cancel</button>
			<button type="button" class="save" onclick="saveViewpoint()">Save</button>
		</div>
	</div>
	
	<script type="module">
		// Initialize material first - optimized for point cloud rendering
		const pointMaterial = new THREE.PointsMaterial({
			size: 2.0,
			vertexColors: true,
			sizeAttenuation: false,
			transparent: false,
			opacity: 1.0,
			alphaTest: 0.1,
			precision: 'lowp', // Use low precision for better performance
			blending: THREE.NoBlending
		});

		window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
		
		// Add draw dropdown toggle functionality
		const drawToggle = document.getElementById('drawToggle');
		const drawDropdown = document.getElementById('drawDropdown');
		let isDrawDropdownOpen = false;

		drawToggle.addEventListener('click', (e) => {
			e.stopPropagation();
			isDrawDropdownOpen = !isDrawDropdownOpen;
			drawDropdown.classList.toggle('show');
		});

		// Close dropdown when clicking outside
		document.addEventListener('click', () => {
			if (isDrawDropdownOpen) {
				isDrawDropdownOpen = false;
				drawDropdown.classList.remove('show');
			}
		});

		viewer.setEDLEnabled(true);
		viewer.setFOV(60);
		viewer.setPointBudget(1_000_000);
		viewer.loadSettingsFromURL();
		viewer.setBackground("black");
		
		viewer.loadGUI(() => {
			viewer.setLanguage('en');
			
			// Switch to first person controls for better handling
			viewer.setControls(viewer.fpControls);
			
			if (viewer.fpControls) {
				// Configure first person controls for smooth movement
				viewer.fpControls.lockElevation = false;
				viewer.fpControls.moveSpeed = 1.0;
				
				// Direct zoom implementation on render area
				const renderArea = document.getElementById('potree_render_area');
				renderArea.addEventListener('wheel', (e) => {
					e.preventDefault();
					e.stopPropagation();
					
					const camera = viewer.scene.getActiveCamera();
					const zoomSpeed = 1.0; // Increased speed for more noticeable effect
					
					// Get camera's forward direction
					const forward = new THREE.Vector3();
					camera.getWorldDirection(forward);
					
					if (e.deltaY < 0) {
						// Zoom in - move forward
						camera.position.add(forward.multiplyScalar(zoomSpeed));
					} else {
						// Zoom out - move backward
						camera.position.sub(forward.multiplyScalar(zoomSpeed));
					}
					
					// Update view and controls
					viewer.scene.view.position.copy(camera.position);
					if (viewer.controls.target) {
						viewer.controls.target.add(forward.multiplyScalar(e.deltaY < 0 ? zoomSpeed : -zoomSpeed));
					}
				}, { passive: false });

				// WASD movement
				window.addEventListener('keydown', (event) => {
					const moveSpeed = viewer.getMoveSpeed() * 0.2;
					const camera = viewer.scene.getActiveCamera();
					const direction = new THREE.Vector3();
					camera.getWorldDirection(direction);
					const right = new THREE.Vector3();
					
					switch(event.code) {
						case 'KeyW':
							camera.position.addScaledVector(direction, moveSpeed);
							viewer.controls.target.addScaledVector(direction, moveSpeed);
							break;
						case 'KeyS':
							camera.position.addScaledVector(direction, -moveSpeed);
							viewer.controls.target.addScaledVector(direction, -moveSpeed);
							break;
						case 'KeyA':
							camera.position.addScaledVector(right, -moveSpeed);
							viewer.controls.target.addScaledVector(right, -moveSpeed);
							break;
						case 'KeyD':
							camera.position.addScaledVector(right, moveSpeed);
							viewer.controls.target.addScaledVector(right, moveSpeed);
							break;
					}
					
					viewer.scene.view.position.copy(camera.position);
				});
			}

			// Hide unnecessary UI
			$('#menu_appearance').hide();
			$('#menu_about').hide();
			$('#menu_language').hide();
			$('.divider').hide();
			$('#potree_languages').remove();
		});
		
		// Initialize LASLaz loader
		const LASLazLoader = await import('../src/loader/LasLazLoader.js');
		
		// Create secondary renderer for top view
		const topViewRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
		topViewRenderer.setSize(300, 300);
		topViewRenderer.setClearColor(0x000000, 0.5); // More opaque background for better contrast
		const topViewContainer = document.getElementById('top_view_map');
		topViewContainer.appendChild(topViewRenderer.domElement);
		
		// Add raycaster for map interaction
		const mapRaycaster = new THREE.Raycaster();
		const mapMouse = new THREE.Vector2();
		
		// Add click event listener to the map view
		topViewRenderer.domElement.addEventListener('click', (event) => {
			// Calculate mouse position in normalized device coordinates
			const rect = topViewRenderer.domElement.getBoundingClientRect();
			mapMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
			mapMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
			
			// Set raycaster from mouse position
			mapRaycaster.setFromCamera(mapMouse, topViewCamera);
			
			// Find intersections with point clouds in the top view
			const pointClouds = topViewScene.children.filter(child => 
				child instanceof THREE.Points
			);
			
			if (pointClouds.length > 0) {
				const intersects = mapRaycaster.intersectObjects(pointClouds);
				
				if (intersects.length > 0) {
					const intersection = intersects[0];
					
					// Get the point of intersection
					const targetPoint = intersection.point.clone();
					
					// Move main camera to that X,Y position but keep Z height
					const mainCamera = viewer.scene.getActiveCamera();
					const currentHeight = mainCamera.position.z;
					mainCamera.position.set(targetPoint.x, targetPoint.y, currentHeight);
					
					// Update view to look at clicked point
					viewer.scene.view.position.copy(mainCamera.position);
					
					// Create a temporary marker to show where user clicked
					const markerGeometry = new THREE.SphereGeometry(1, 16, 16);
					const markerMaterial = new THREE.MeshBasicMaterial({
						color: 0x00ff00,
						transparent: true,
						opacity: 0.8
					});
					const marker = new THREE.Mesh(markerGeometry, markerMaterial);
					marker.position.copy(targetPoint);
					marker.position.z += 0.2; // Offset to ensure visibility
					topViewScene.add(marker);
					
					// Create a pulsing animation for the marker
					let scale = 1.0;
					let growing = false;
					const pulseAnimation = setInterval(() => {
						if (growing) {
							scale += 0.1;
							if (scale >= 1.5) growing = false;
						} else {
							scale -= 0.1;
							if (scale <= 0.5) growing = true;
						}
						marker.scale.set(scale, scale, scale);
					}, 50);
					
					// Remove marker after 1 second
					setTimeout(() => {
						clearInterval(pulseAnimation);
						topViewScene.remove(marker);
						marker.geometry.dispose();
						marker.material.dispose();
					}, 1000);
				}
			}
		});
		
		// Add hover effect to show clickable areas
		topViewRenderer.domElement.addEventListener('mousemove', (event) => {
			const rect = topViewRenderer.domElement.getBoundingClientRect();
			mapMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
			mapMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
			
			// Update cursor based on whether it's over a point cloud
			mapRaycaster.setFromCamera(mapMouse, topViewCamera);
			const pointClouds = topViewScene.children.filter(child => 
				child instanceof THREE.Points
			);
			
			if (pointClouds.length > 0) {
				const intersects = mapRaycaster.intersectObjects(pointClouds);
				if (intersects.length > 0) {
					topViewRenderer.domElement.style.cursor = 'pointer';
				} else {
					topViewRenderer.domElement.style.cursor = 'default';
				}
			}
		});
		
		// Create camera for top view
		const topViewCamera = new THREE.OrthographicCamera(-150, 150, 150, -150, 0.1, 1000);
		topViewCamera.position.set(0, 0, 100); // Position directly above, looking down along Z axis
		topViewCamera.lookAt(new THREE.Vector3(0, 0, 0));
		topViewCamera.up.set(0, 1, 0); // Set up vector to Y-axis for standard top view
		// Reset any previous rotation
		topViewCamera.rotation.set(0, 0, 0);
		
		// Create scene for top view
		const topViewScene = new THREE.Scene();
		
		// Add ambient light to ensure points are visible
		topViewScene.add(new THREE.AmbientLight(0xffffff, 1.0));
		
		// Add visual border for reference
		const mapBorder = new THREE.LineSegments(
			new THREE.EdgesGeometry(new THREE.BoxGeometry(290, 290, 0)),
			new THREE.LineBasicMaterial({ color: 0x4B6BFD, transparent: true, opacity: 0.7 })
		);
		topViewScene.add(mapBorder);
		
		// Add reference grid
		const grid = new THREE.GridHelper(300, 10, 0x555555, 0x333333);
		// No rotation needed for standard top view with Z as up
		grid.rotation.x = 0;
		topViewScene.add(grid);
		
		// Create a group for the camera indicator
		const cameraIndicator = new THREE.Group();

		// Small dot to show position
		const positionDot = new THREE.Mesh(
			new THREE.CircleGeometry(0.5, 16), // Reduced from larger size
			new THREE.MeshBasicMaterial({ 
				color: 0xff3333, 
				transparent: true,
				opacity: 0.8 
			})
		);
		// No additional rotation needed for standard top view
		positionDot.rotation.x = 0;
		cameraIndicator.add(positionDot);

		// Small arrow to show direction
		const directionArrow = new THREE.Mesh(
			new THREE.ConeGeometry(0.4, 1, 8), // Reduced from larger size
			new THREE.MeshBasicMaterial({ 
				color: 0xff5555, 
				transparent: true,
				opacity: 0.8 
			})
		);
		directionArrow.position.set(0, 0.75, 0); // Adjust for top view
		directionArrow.rotation.x = 0;
		directionArrow.rotation.z = Math.PI / 2; // Point forward
		cameraIndicator.add(directionArrow);

		// Small glow circle around position
		const glowCircle = new THREE.Mesh(
			new THREE.RingGeometry(0.6, 0.8, 16), // Reduced from larger size
			new THREE.MeshBasicMaterial({ 
				color: 0xff8888, 
				transparent: true, 
				opacity: 0.4,
				side: THREE.DoubleSide
			})
		);
		// No additional rotation needed for standard top view
		glowCircle.rotation.x = 0;
		cameraIndicator.add(glowCircle);
		
		topViewScene.add(cameraIndicator);
		
		// Initialize map controls
		let mapVisible = false; // Set map to hidden by default
		document.getElementById('top_view_map').style.display = mapVisible ? 'block' : 'none'; // Add this line to set initial display
		let initialZoomFactor = 3.0; // Increased from 1.2 to show more of the point cloud
		let currentZoomFactor = initialZoomFactor;
		let originalBoundingBox = null;
		let boxCenter = new THREE.Vector3(0, 0, 0);
		let boxSize = new THREE.Vector3(300, 300, 300);
		
		// Map control functions
		document.getElementById('zoomInMap').addEventListener('click', () => {
			currentZoomFactor *= 0.8; // Zoom in 20%
			updateTopViewCamera();
		});
		
		document.getElementById('zoomOutMap').addEventListener('click', () => {
			currentZoomFactor *= 1.2; // Zoom out 20%
			updateTopViewCamera();
		});
		
		document.getElementById('resetMap').addEventListener('click', () => {
			// Reset to a value that provides a good overview of the entire point cloud
			currentZoomFactor = 3.0; // Show a zoomed-out view on reset
			updateTopViewCamera();
		});
		
		document.getElementById('closeMap').addEventListener('click', () => {
			mapVisible = false;
			document.getElementById('top_view_map').style.display = 'none';
		});
		
		function updateTopViewCamera() {
			if (!originalBoundingBox) return;
			
			const maxDim = Math.max(boxSize.x, boxSize.y, boxSize.z) * 1.5; // Show 1.5x more area
			topViewCamera.left = -maxDim / 2 * currentZoomFactor;
			topViewCamera.right = maxDim / 2 * currentZoomFactor;
			topViewCamera.top = maxDim / 2 * currentZoomFactor;
			topViewCamera.bottom = -maxDim / 2 * currentZoomFactor;
			topViewCamera.updateProjectionMatrix();
		}
		
		// Add a toggle button to the minimal-nav for the map
		const minimalNav = document.querySelector('.minimal-nav');
		const mapButton = document.getElementById('mapButton');
		
		mapButton.addEventListener('click', () => {
			mapVisible = !mapVisible;
			document.getElementById('top_view_map').style.display = mapVisible ? 'block' : 'none';
			mapButton.classList.toggle('active', mapVisible);
		});
		
		// Drag and drop functionality
		const dropZone = document.getElementById('dropZone');
		
		// Prevent default drag behaviors
		['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
			document.body.addEventListener(eventName, preventDefaults, false);
		});

		function preventDefaults (e) {
			e.preventDefault();
			e.stopPropagation();
		}

		// Handle drag enter and leave
		['dragenter', 'dragover'].forEach(eventName => {
			document.body.addEventListener(eventName, highlight, false);
		});

		['dragleave', 'drop'].forEach(eventName => {
			document.body.addEventListener(eventName, unhighlight, false);
		});

		function highlight(e) {
			dropZone.style.display = 'flex';
			dropZone.classList.add('active');
		}

		function unhighlight(e) {
			dropZone.style.display = 'none';
			dropZone.classList.remove('active');
		}

		// Handle dropped files
		document.body.addEventListener('drop', handleDrop, false);

		// Add WebGL context loss handling
		const canvas = document.querySelector('#potree_render_area canvas');
		canvas.addEventListener('webglcontextlost', handleContextLost, false);
		canvas.addEventListener('webglcontextrestored', handleContextRestored, false);

		function handleContextLost(event) {
			event.preventDefault();
			console.log('WebGL context lost - suspending rendering');
			viewer.renderer.forceContextLoss();
		}

		function handleContextRestored(event) {
			console.log('WebGL context restored - resuming rendering');
			viewer.renderer.initWebGL();
		}

		async function handleDrop(e) {
			e.preventDefault();
			const dt = e.dataTransfer;
			const files = dt.files;
			unhighlight(e);

			// Hide welcome message
			const welcomeOverlay = document.getElementById('welcomeOverlay');
			if (welcomeOverlay) {
				welcomeOverlay.style.display = 'none';
			}

			// Clear existing point clouds from the top view
			while(topViewScene.children.length > 0) {
				const obj = topViewScene.children[0];
				if (obj.geometry) obj.geometry.dispose();
				if (obj.material) obj.material.dispose();
				topViewScene.remove(obj);
			}
			
			// Re-add the basic elements
			topViewScene.add(new THREE.AmbientLight(0xffffff, 1.0));
			topViewScene.add(mapBorder);
			topViewScene.add(grid);
			topViewScene.add(cameraIndicator);

			// Progress overlay
			const progressDiv = document.createElement('div');
			progressDiv.style.position = 'fixed';
			progressDiv.style.top = '50%';
			progressDiv.style.left = '50%';
			progressDiv.style.transform = 'translate(-50%, -50%)';
			progressDiv.style.background = 'rgba(0,0,0,0.8)';
			progressDiv.style.color = 'white';
			progressDiv.style.padding = '20px';
			progressDiv.style.borderRadius = '10px';
			progressDiv.style.zIndex = '1000';
			document.body.appendChild(progressDiv);

			try {
				for (let file of files) {
					if (!file.name.toLowerCase().endsWith('.las')) {
						throw new Error('Please drop a .las file');
					}

					progressDiv.textContent = 'Loading file...';

					// Read header
					const headerBuffer = await file.slice(0, 375).arrayBuffer();
					const headerView = new DataView(headerBuffer);
					
					const pointDataFormat = headerView.getUint8(104);
					const pointDataRecordLength = headerView.getUint16(105, true);
					const numPoints = headerView.getUint32(107, true);
					const pointDataOffset = headerView.getUint32(96, true);

					// Get scale and offset
					const scaleX = headerView.getFloat64(131, true);
					const scaleY = headerView.getFloat64(139, true);
					const scaleZ = headerView.getFloat64(147, true);
					
					const offsetX = headerView.getFloat64(155, true);
					const offsetY = headerView.getFloat64(163, true);
					const offsetZ = headerView.getFloat64(171, true);

					// Optimize batch size for low memory
					const POINTS_PER_BATCH = 50000; // Smaller batches for lower memory usage
					const BATCH_BYTE_SIZE = POINTS_PER_BATCH * pointDataRecordLength;
					const totalBatches = Math.ceil(numPoints / POINTS_PER_BATCH);

					let processedPoints = 0;
					let positions = [];
					let colors = [];
					let currentGeometry = null;

					// Calculate decimation factor based on total points
					const decimationFactor = Math.max(1, Math.floor(numPoints / 2000000)); // Limit total points to ~2M

					for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
						const start = pointDataOffset + (batchIndex * BATCH_BYTE_SIZE);
						const end = Math.min(start + BATCH_BYTE_SIZE, file.size);
						
						if (start >= file.size) break;

						progressDiv.textContent = `Loading points: ${Math.round((batchIndex / totalBatches) * 100)}%`;
						
						const chunkBuffer = await file.slice(start, end).arrayBuffer();
						const dataView = new DataView(chunkBuffer);

						for (let offset = 0; offset < chunkBuffer.byteLength - pointDataRecordLength; offset += pointDataRecordLength * decimationFactor) {
							const x = dataView.getInt32(offset, true) * scaleX + offsetX;
							const y = dataView.getInt32(offset + 4, true) * scaleY + offsetY;
							const z = dataView.getInt32(offset + 8, true) * scaleZ + offsetZ;

							// Basic color handling for performance
							let r = 1.0, g = 1.0, b = 1.0;
							if (pointDataFormat >= 2) {
								const colorOffset = offset + 20;
								if (colorOffset + 6 <= chunkBuffer.byteLength) {
									r = dataView.getUint16(colorOffset, true) / 65535;
									g = dataView.getUint16(colorOffset + 2, true) / 65535;
									b = dataView.getUint16(colorOffset + 4, true) / 65535;
								}
							}

							positions.push(x, y, z);
							colors.push(r, g, b);

							processedPoints++;
							if (processedPoints >= numPoints) break;
						}

						// Create point cloud every 500K points or on last batch
						if (positions.length >= 1500000 || batchIndex === totalBatches - 1) {
							if (currentGeometry) {
								currentGeometry.dispose(); // Clean up previous geometry
							}
							
							currentGeometry = new THREE.BufferGeometry();
							currentGeometry.setAttribute(
								'position',
								new THREE.Float32BufferAttribute(positions, 3)
							);
							currentGeometry.setAttribute(
								'color',
								new THREE.Float32BufferAttribute(colors, 3)
							);

							const pointcloud = new THREE.Points(currentGeometry, pointMaterial);
							viewer.scene.scene.add(pointcloud);

							// Create a clone for the top view map with simplified material
							const topViewMaterial = new THREE.PointsMaterial({
								size: 1.5, // Increased point size for better visibility
								vertexColors: true,
								sizeAttenuation: false,
								opacity: 0.9,  // Slightly transparent to see overlapping points
								transparent: true
							});
							const topViewPointCloud = new THREE.Points(currentGeometry.clone(), topViewMaterial);
							// Add name to make it easier to identify
							topViewPointCloud.name = 'topViewPointCloud';
							topViewScene.add(topViewPointCloud);

							// Calculate bounding box of the point cloud
							currentGeometry.computeBoundingBox();
							const box = currentGeometry.boundingBox;
							const center = box.getCenter(new THREE.Vector3());
							const size = box.getSize(new THREE.Vector3());
							const maxDim = Math.max(size.x, size.y, size.z);

							// Store original bounding box info for map controls
							originalBoundingBox = box.clone();
							boxCenter = center.clone();
							boxSize = size.clone();

							// Set up top view camera - perfect top view (roof view)
							topViewCamera.left = -maxDim / 2 * initialZoomFactor;
							topViewCamera.right = maxDim / 2 * initialZoomFactor;
							topViewCamera.top = maxDim / 2 * initialZoomFactor;
							topViewCamera.bottom = -maxDim / 2 * initialZoomFactor;
							// Position camera for true top view (looking down the Z axis)
							topViewCamera.position.set(center.x, center.y, center.z + maxDim * 10);
							topViewCamera.lookAt(center);
							// Standard top view has Y as up
							topViewCamera.up.set(0, 1, 0);
							// Reset any previous rotation
							topViewCamera.rotation.set(0, 0, 0);
							topViewCamera.updateProjectionMatrix();

							// Position the map border and grid
							mapBorder.position.set(center.x, center.y, center.z);
							grid.position.set(center.x, center.y, center.z);
							grid.scale.set(maxDim/300, maxDim/300, maxDim/300);

							// Calculate a more appropriate view distance based on the model size
							// This prevents excessive zoom and maintains a good overview
							const viewDistanceFactor = 2.0; // Adjust this factor to control initial zoom level
							const initialViewDistance = maxDim * viewDistanceFactor;
							
							// Set up initial camera position for main view at a reasonable distance
							viewer.scene.view.position.set(
								center.x,
								center.y - initialViewDistance * 0.8,
								center.z + initialViewDistance * 0.5
							);

							// Look at the center of the point cloud
							viewer.scene.view.lookAt(center);

							// Don't automatically fit to screen after loading
							// viewer.fitToScreen();  // Removed to prevent excessive zoom

							// Adjust FOV for a better perspective view
							viewer.setFOV(60);
							
							// Set proper move speed based on point cloud size
							const moveSpeed = maxDim / 10;
							viewer.setMoveSpeed(moveSpeed);

							// Add or update render loop for the top view
							if (!window.topViewRenderLoopStarted) {
								window.topViewRenderLoopStarted = true;
								
								function renderTopView() {
									if (mapVisible) {
										// Update camera indicator position based on main camera
										const mainCamera = viewer.scene.getActiveCamera();
										// For top view, we place the indicator at the X,Y coordinates
										// and keep a small Z offset
										cameraIndicator.position.set(
											mainCamera.position.x,
											mainCamera.position.y,
											0.1 // Small offset to keep it above the point cloud
										);
										
										// Get camera direction
										const direction = new THREE.Vector3();
										mainCamera.getWorldDirection(direction);
										
										// For true top view, rotation is around Z axis (looking down)
										// Calculate the angle in the XY plane
										cameraIndicator.rotation.z = Math.atan2(direction.y, direction.x);
										
										// Add subtle pulsing effect to the glow circle
										const pulseFactor = 0.2 * Math.sin(Date.now() * 0.005) + 1;
										glowCircle.scale.set(pulseFactor, pulseFactor, 1);
										
										// Render the top view
										topViewRenderer.render(topViewScene, topViewCamera);
									}
									
									requestAnimationFrame(renderTopView);
								}
								
								renderTopView();
							}

							// Switch to First Person controls
							viewer.setControls(viewer.fpControls);
							if (viewer.fpControls) {
								viewer.fpControls.moveSpeed = moveSpeed;
								viewer.fpControls.lockElevation = false;
								viewer.fpControls.enableDamping = true;
								viewer.fpControls.dampingFactor = 0.05;
							}

							// Enable keyboard controls
							window.addEventListener('keydown', (event) => {
								const moveDistance = moveSpeed * 0.1;
								switch(event.code) {
									case 'KeyW':
										viewer.scene.view.position.z -= moveDistance;
										break;
									case 'KeyS':
										viewer.scene.view.position.z += moveDistance;
										break;
									case 'KeyA':
										viewer.scene.view.position.x -= moveDistance;
										break;
									case 'KeyD':
										viewer.scene.view.position.x += moveDistance;
										break;
								}
							});

							// Clear arrays
							positions = [];
							colors = [];

							// Force garbage collection and pause
							if (window.gc) window.gc();
							await new Promise(resolve => setTimeout(resolve, 10)); // Longer pause for memory cleanup
						}
					}
				}
			} catch (error) {
				console.error('Error:', error);
				alert(`Error loading file: ${error.message}`);
			} finally {
				document.body.removeChild(progressDiv);
			}
		}
		
		// Measurement Functions
		function toggleMeasurement(type) {
			document.querySelectorAll('.nav-button').forEach(btn => btn.classList.remove('active'));
			const button = document.querySelector(`[title="${type === 'distance' ? 'Distance' : 'Angle'} Measurement"]`);
			button.classList.add('active');
			// Add measurement logic here
		}

		function toggleComments() {
			const button = document.querySelector('[title="Add Comment"]');
			button.classList.toggle('active');
			// Add comment functionality here
		}

		function toggleSearch() {
			const button = document.querySelector('[title="Search"]');
			button.classList.toggle('active');
			// Add search functionality here
		}

		// Camera menu functions
		window.toggleCameraMenu = function(event) {
			event.stopPropagation(); // Prevent event from bubbling up
			const dropdown = document.getElementById('cameraDropdown');
			dropdown.classList.toggle('show');
			
			// Close dropdown when clicking outside
			const closeDropdown = (e) => {
				if (!e.target.closest('.nav-dropdown')) {
					dropdown.classList.remove('show');
					document.removeEventListener('click', closeDropdown);
				}
			};
			
			document.addEventListener('click', closeDropdown);
		};

		window.handleCameraOption = function(option) {
			switch(option) {
				case 'screenshot':
					takeScreenshot();
					break;
				case 'pov':
					showSaveViewpointDialog();
					break;
			}
			
			document.getElementById('cameraDropdown').classList.remove('show');
		};

		window.takeScreenshot = function() {
			const dialog = document.getElementById('screenshotDialog');
			dialog.style.display = 'block';
		};

		window.closeScreenshotDialog = function() {
			const dialog = document.getElementById('screenshotDialog');
			dialog.style.display = 'none';
		};

		window.takeScreenshotWithResolution = async function() {
			const button = document.querySelector('[title="Camera"]');
			button.classList.add('active');
			
			const resolutionStr = document.getElementById('resolutionSelect').value;
			let width, height;
			
			if (resolutionStr === 'current') {
				width = viewer.renderer.domElement.width;
				height = viewer.renderer.domElement.height;
			} else {
				[width, height] = resolutionStr.split('x').map(Number);
			}
			
			try {
				// Save current canvas size
				const originalWidth = viewer.renderer.domElement.width;
				const originalHeight = viewer.renderer.domElement.height;
				
				// Temporarily resize renderer
				viewer.renderer.setSize(width, height);
				
				// Force a render at new size
				viewer.renderer.render(viewer.scene.scene, viewer.scene.getActiveCamera());
				
				// Take screenshot
				const screenshot = viewer.renderer.domElement.toDataURL('image/png');
				
				// Create temporary link to download
				const link = document.createElement('a');
				link.href = screenshot;
				link.download = `screenshot_${width}x${height}.png`;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				
				// Restore original size
				viewer.renderer.setSize(originalWidth, originalHeight);
				viewer.renderer.render(viewer.scene.scene, viewer.scene.getActiveCamera());
				
				button.classList.remove('active');
				closeScreenshotDialog();
			} catch (error) {
				console.error('Screenshot error:', error);
				alert('Failed to take screenshot. Please try again.');
				button.classList.remove('active');
				closeScreenshotDialog();
			}
		};

		// Close dialog when clicking outside
		document.addEventListener('click', function(event) {
			const dialog = document.getElementById('screenshotDialog');
			if (event.target === dialog) {
				closeScreenshotDialog();
			}
		});

		window.startVideoAnimation = function() {
			const animation = new Potree.CameraAnimation(viewer);
			animation.setVisible(true);
			viewer.scene.cameraAnimations.push(animation);
		};

		window.startObjectAnimation = function() {
			// Create an orbit animation around the current target
			const camera = viewer.scene.getActiveCamera();
			const target = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(100));
			
			const animation = new Potree.CameraAnimation(viewer);
			animation.setVisible(true);
			
			// Add control points for a circular path
			const radius = 100;
			const points = 8;
			for(let i = 0; i <= points; i++) {
				const angle = (i / points) * Math.PI * 2;
				const x = target.x + radius * Math.cos(angle);
				const z = target.z + radius * Math.sin(angle);
				const position = new THREE.Vector3(x, target.y, z);
				
				animation.addControlPoint({
					position: position,
					target: target
				});
			}
			
			viewer.scene.cameraAnimations.push(animation);
		};

		

		// Drawing Tools Functions
		function toggleDraw() {
			const button = document.querySelector('[title="Draw"]');
			button.classList.toggle('active');
			// Add drawing mode toggle here
		}

		// Make functions globally accessible
		window.toggleTransform = function() {
			const button = document.querySelector('[title="Zoomed in view"]');
			button.classList.toggle('active');
			
			// Get all point clouds and their bounds
			const box = viewer.getBoundingBox(viewer.scene.pointclouds);
			const size = box.getSize(new THREE.Vector3());
			const center = box.getCenter(new THREE.Vector3());
			const maxDim = Math.max(size.x, size.y, size.z);
			
			// Set to perspective mode for panoramic view
			viewer.setCameraMode(1);  // PERSPECTIVE
			
			// Position camera at an elevated angle for panoramic view
			const distance = maxDim * 1.5;  // Closer distance for better detail
			viewer.scene.view.position.set(
				center.x - distance,  // Position camera diagonally for panoramic view
				center.y - distance,
				center.z + distance * 0.75  // Slightly lower height for better perspective
			);
			
			// Set view parameters for panoramic angle
			viewer.scene.view.pitch = -Math.PI / 6;  // -30 degrees for panoramic angle
			viewer.scene.view.yaw = Math.PI / 4;     // 45 degrees rotation for diagonal view
			viewer.scene.view.radius = distance;
			
			// Set a wider field of view for panoramic effect
			viewer.setFOV(75);
			
			// Ensure the entire point cloud is visible
			viewer.fitToScreen();
		};

		window.toggleFullscreenView = function() {
			const button = document.querySelector('[title="Fullscreen View"]');
			button.classList.toggle('active');
			
			const renderArea = document.getElementById('potree_render_area');
			const container = document.querySelector('.potree_container');
			const dropZone = document.getElementById('dropZone');
			const welcomeOverlay = document.getElementById('welcomeOverlay');
			
			// Function to handle fullscreen changes
			function onFullscreenChange() {
				if (document.fullscreenElement) {
					// Update viewer size for fullscreen
					viewer.setDimensions(window.innerWidth, window.innerHeight);
					viewer.renderer.setSize(window.innerWidth, window.innerHeight);
					
					// Ensure container covers full screen
					container.style.width = '100vw';
					container.style.height = '100vh';
					container.style.position = 'fixed';
					container.style.left = '0';
					container.style.top = '0';
					
					// Update drop zone for fullscreen
					if (dropZone) {
						dropZone.style.position = 'fixed';
						dropZone.style.width = '100vw';
						dropZone.style.height = '100vh';
						dropZone.style.left = '0';
						dropZone.style.top = '0';
						dropZone.style.zIndex = '10000';
					}
					
					// Update welcome overlay for fullscreen
					if (welcomeOverlay) {
						welcomeOverlay.style.position = 'fixed';
						welcomeOverlay.style.zIndex = '10001';
					}
					
					// Ensure the minimal-nav stays on top
					const minimalNav = document.querySelector('.minimal-nav');
					if (minimalNav) {
						minimalNav.style.zIndex = '10002';
					}
					
				} else {
					// Restore original size
					viewer.setDimensions(renderArea.clientWidth, renderArea.clientHeight);
					viewer.renderer.setSize(renderArea.clientWidth, renderArea.clientHeight);
					
					// Restore container size
					container.style.width = '100%';
					container.style.height = '100%';
					container.style.position = 'absolute';
					
					// Restore drop zone
					if (dropZone) {
						dropZone.style.position = 'fixed';
						dropZone.style.width = '100%';
						dropZone.style.height = '100%';
						dropZone.style.zIndex = '1000';
					}
					
					// Restore welcome overlay
					if (welcomeOverlay) {
						welcomeOverlay.style.position = 'fixed';
						welcomeOverlay.style.zIndex = '999';
					}
					
					// Restore minimal-nav z-index
					const minimalNav = document.querySelector('.minimal-nav');
					if (minimalNav) {
						minimalNav.style.zIndex = '1000';
					}
				}
				
				// Force a re-render
				viewer.renderer.render(viewer.scene.scene, viewer.scene.getActiveCamera());
			}

			// Add fullscreen change event listeners
			document.addEventListener('fullscreenchange', onFullscreenChange);
			document.addEventListener('webkitfullscreenchange', onFullscreenChange);
			document.addEventListener('mozfullscreenchange', onFullscreenChange);
			document.addEventListener('MSFullscreenChange', onFullscreenChange);
			
			if (!document.fullscreenElement) {
				// Enter fullscreen
				if (container.requestFullscreen) {
					container.requestFullscreen();
				} else if (container.webkitRequestFullscreen) { // Safari
					container.webkitRequestFullscreen();
				} else if (container.msRequestFullscreen) { // IE11
					container.msRequestFullscreen();
				}
			} else {
				// Exit fullscreen
				if (document.exitFullscreen) {
					document.exitFullscreen();
				} else if (document.webkitExitFullscreen) { // Safari
					document.webkitExitFullscreen();
				} else if (document.msExitFullscreen) { // IE11
					document.msExitFullscreen();
				}
			}
		};

		window.showSaveViewpointDialog = function() {
			const dialog = document.getElementById('saveViewpointDialog');
			dialog.style.display = 'block';
			document.getElementById('viewpointName').value = '';
			document.getElementById('viewpointName').focus();
		};

		window.closeSaveViewpointDialog = function(event) {
			if (event) {
				event.preventDefault();
				event.stopPropagation();
			}
			
			// Remove console.log
			const dialog = document.getElementById('saveViewpointDialog');
			if (dialog) {
				dialog.style.display = 'none';
			}
			return false;
		};

		window.saveViewpoint = function() {
			const name = document.getElementById('viewpointName').value.trim();
			if (!name) {
				alert('Please enter a name for the viewpoint');
				return;
			}

			const camera = viewer.scene.getActiveCamera();
			const viewpoint = {
				id: Date.now(),
				name: name,
				position: camera.position.clone(),
				target: viewer.scene.view.position.clone(),
				timestamp: new Date().toLocaleString()
			};

			savedViewpoints.push(viewpoint);
			updateViewpointsList();
			closeSaveViewpointDialog();
			toggleViewpointsPanel(true);

			// Save to localStorage
			localStorage.setItem('savedViewpoints', JSON.stringify(savedViewpoints));
		};

		window.toggleViewpointsPanel = function(show) {
			const panel = document.getElementById('savedViewpointsPanel');
			panel.style.display = show ? 'block' : 'none';
		};

		window.loadViewpoint = function(viewpoint) {
			const camera = viewer.scene.getActiveCamera();
			
			// Create a smooth transition
			const duration = 1000; // 1 second
			const startPos = camera.position.clone();
			const startTarget = viewer.scene.view.position.clone();
			const startTime = Date.now();

			function animate() {
				const elapsed = Date.now() - startTime;
				const progress = Math.min(elapsed / duration, 1);
				
				// Use easing function for smooth transition
				const eased = 1 - Math.pow(1 - progress, 3);

				camera.position.lerpVectors(startPos, viewpoint.position, eased);
				viewer.scene.view.position.lerpVectors(startTarget, viewpoint.target, eased);
				
				if (progress < 1) {
					requestAnimationFrame(animate);
				}
			}

			animate();
		};

		window.deleteViewpoint = function(id, event) {
			if (event) {
				event.stopPropagation();
			}
			
			// Convert to let if it was const before
			let savedViewpointsVar = window.savedViewpoints || savedViewpoints;
			
			// Filter out the viewpoint with the given id
			savedViewpointsVar = savedViewpointsVar.filter(vp => vp.id !== id);
			
			// Update global references
			if (window.savedViewpoints) window.savedViewpoints = savedViewpointsVar;
			savedViewpoints = savedViewpointsVar;
			
			// Update the UI
			updateViewpointsList();
			
			// Save to localStorage
			localStorage.setItem('savedViewpoints', JSON.stringify(savedViewpointsVar));
			
			return false; // Prevent any other handlers from executing
		};
		
		function updateViewpointsList() {
			const list = document.getElementById('viewpointList');
			if (!list) return;
			
			list.innerHTML = '';
			
			let viewpointsToDisplay = window.savedViewpoints || savedViewpoints;
			if (!viewpointsToDisplay || !Array.isArray(viewpointsToDisplay)) {
				console.error("No viewpoints array found");
				return;
			}

			viewpointsToDisplay.forEach(viewpoint => {
				// Create main container
				const item = document.createElement('div');
				item.className = 'viewpoint-item';
				
				// Create name span
				const nameSpan = document.createElement('span');
				nameSpan.textContent = viewpoint.name;
				nameSpan.style.flexGrow = '1';
				item.appendChild(nameSpan);
				
				// Create container for the delete button to isolate it from the item click
				const btnContainer = document.createElement('div');
				btnContainer.style.position = 'relative';
				btnContainer.style.zIndex = '20';
				
				// Create delete button with better handling
				const deleteBtn = document.createElement('button');
				deleteBtn.className = 'delete-btn';
				deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
				deleteBtn.title = 'Delete viewpoint';
				
				// Use direct event handler
				deleteBtn.addEventListener('click', function(e) {
					e.stopPropagation();
					e.preventDefault();
					
					// Remove console.log
					
					try {
						// Delete the viewpoint - do a direct localStorage update first
						const currentViewpoints = JSON.parse(localStorage.getItem('savedViewpoints') || '[]');
						const updatedViewpoints = currentViewpoints.filter(vp => vp.id !== viewpoint.id);
						localStorage.setItem('savedViewpoints', JSON.stringify(updatedViewpoints));
						
						// Update window global regardless of scope
						window.savedViewpoints = updatedViewpoints.map(vp => ({
							...vp,
							position: new THREE.Vector3(vp.position.x, vp.position.y, vp.position.z),
							target: new THREE.Vector3(vp.target.x, vp.target.y, vp.target.z)
						}));
						
						// Try to update local variable safely if it exists in this scope
						if (typeof savedViewpoints !== 'undefined') {
							try {
								// Try/catch in case it's a const
								savedViewpoints = window.savedViewpoints;
							} catch (e) {
								// Remove console.log
							}
						}
						
						// Update UI directly instead of through updateViewpointsList to avoid const issues
						e.target.closest('.viewpoint-item').remove();
						
						// Remove console.log
					} catch (error) {
						console.error('Error deleting viewpoint:', error);
					}
					
					return false;
				});
				
				btnContainer.appendChild(deleteBtn);
				item.appendChild(btnContainer);
				
				// Add click handler to load viewpoint (only for the item, not the delete button)
				item.addEventListener('click', function(e) {
					if (!e.target.closest('.delete-btn')) {
						window.loadViewpoint(viewpoint);
					}
				});
				
				list.appendChild(item);
			});
		}

		// Load saved viewpoints from localStorage on startup
		document.addEventListener('DOMContentLoaded', () => {
			const saved = localStorage.getItem('savedViewpoints');
			if (saved) {
				savedViewpoints = JSON.parse(saved);
				savedViewpoints.forEach(vp => {
					vp.position = new THREE.Vector3(vp.position.x, vp.position.y, vp.position.z);
					vp.target = new THREE.Vector3(vp.target.x, vp.target.y, vp.target.z);
				});
				updateViewpointsList();
			}
		});

		// Add a direct event listener to the cancel button
		document.addEventListener('DOMContentLoaded', function() {
			const cancelButton = document.querySelector('#saveViewpointDialog .cancel');
			if (cancelButton) {
				cancelButton.addEventListener('click', function(e) {
					e.preventDefault();
					e.stopPropagation();
					window.closeSaveViewpointDialog(e);
					return false;
				});
			}
		});
	</script>
	
	<!-- Fix for Save Viewpoint dialog buttons -->
	<script>
	document.addEventListener('DOMContentLoaded', function() {
		// Fix for Cancel button in Save Viewpoint dialog
		const cancelBtn = document.getElementById('cancelViewpointBtn');
		if (cancelBtn) {
			cancelBtn.addEventListener('click', function(e) {
				e.preventDefault();
				e.stopPropagation();
				
				// Close the save viewpoint dialog directly
				const dialog = document.getElementById('saveViewpointDialog');
				if (dialog) {
					dialog.style.display = 'none';
				}
				
				// Remove console.log
				return false;
			});
		}
		
		// Add clear all viewpoints functionality
		const clearAllBtn = document.getElementById('clearAllViewpoints');
		if (clearAllBtn) {
			clearAllBtn.addEventListener('click', function(e) {
				e.preventDefault();
				e.stopPropagation();
				
				// Confirm with the user
				if (confirm('Are you sure you want to delete all saved viewpoints? This cannot be undone.')) {
					// Clear all viewpoints from localStorage
					localStorage.removeItem('savedViewpoints');
					
					// Reset the global viewpoints array
					window.savedViewpoints = [];
					if (typeof savedViewpoints !== 'undefined') {
						savedViewpoints = [];
					}
					
					// Update the UI
					const list = document.getElementById('viewpointList');
					if (list) {
						list.innerHTML = '';
					}
					
					// Remove console.log
				}
				
				return false;
			});
		}
		
		// Also add a keyboard listener for the ESC key
		document.addEventListener('keydown', function(e) {
			if (e.key === 'Escape') {
				const dialog = document.getElementById('saveViewpointDialog');
				if (dialog && dialog.style.display === 'block') {
					dialog.style.display = 'none';
					// Remove console.log
				}
			}
		});
	});
	</script>
</body>
</html>